<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面向对象编程 | 余音的博客</title><meta name="keywords" content="博客，余音"><meta name="author" content="余音"><meta name="copyright" content="余音"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="包包 (package) 是组织类的一种方式. 使用包的主要目的是保证类的唯一性  例如, 你在代码中写了一个 Test 类. 然后你的同事也可能写一个 Test 类. 如果出现两个同名的类, 就会冲突, 导致代码不能编译通过  导入包中的类Java中提供了很多现成的类供给我们使用，例如 1234567public class Test &amp;#123;    public static void m">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象编程">
<meta property="og:url" content="http://example.com/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="余音的博客">
<meta property="og:description" content="包包 (package) 是组织类的一种方式. 使用包的主要目的是保证类的唯一性  例如, 你在代码中写了一个 Test 类. 然后你的同事也可能写一个 Test 类. 如果出现两个同名的类, 就会冲突, 导致代码不能编译通过  导入包中的类Java中提供了很多现成的类供给我们使用，例如 1234567public class Test &amp;#123;    public static void m">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252041482.jfif">
<meta property="article:published_time" content="2021-12-03T12:56:27.000Z">
<meta property="article:modified_time" content="2021-12-03T12:57:02.222Z">
<meta property="article:author" content="余音">
<meta property="article:tag" content="博客，余音">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252041482.jfif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面向对象编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-03 20:57:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/constown/HexoCustomFile@0.0.4/dist/css/custom.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111251736783.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252041482.jfif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">余音的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面向对象编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-03T12:56:27.000Z" title="发表于 2021-12-03 20:56:27">2021-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-03T12:57:02.222Z" title="更新于 2021-12-03 20:57:02">2021-12-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面向对象编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包 (package) 是组织类的一种方式.</p>
<p>使用包的主要目的是保证类的唯一性</p>
<blockquote>
<p>例如, 你在代码中写了一个 Test 类. 然后你的同事也可能写一个 Test 类. 如果出现两个同名的类, 就会冲突, 导致代码不能编译通过</p>
</blockquote>
<h2 id="导入包中的类"><a href="#导入包中的类" class="headerlink" title="导入包中的类"></a>导入包中的类</h2><p>Java中提供了很多现成的类供给我们使用，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">        <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>java.util.Date</code>这种方式引入 <code>java.util</code> 这个包中的 Date 类.</p>
<p>但是这种写法比较麻烦一些, 可以使用 import 语句导入包.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要使用<code> java.util</code> 中的其他类, 可以使用 <code>import java.util.*</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们更建议显式的指定要导入的类名. 否则还是容易出现冲突的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// util 和 sql 中都存在一个 Date 这样的类, 此时就会出现歧义, 编译出错</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202112031330268.png" alt="image-20211203133041515"></p>
<blockquote>
<p>因为不知道调用的是哪个包里的<strong>Date</strong>，导致编译错误。</p>
</blockquote>
<p>在这种情况下需要使用完整的类名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般的调用那个类，调用那个类，如果出现重复的类名的话，就需要使用完整的类名。</p>
</blockquote>
<h2 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h2><p>使用<code>import static</code> 可以导入包中的静态的方法和字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="把类放入包中"><a href="#把类放入包中" class="headerlink" title="把类放入包中"></a>把类放入包中</h2><p><strong>基本规则</strong></p>
<blockquote>
<p>在文件的最上方加上一个 package 语句指定该代码在哪个包中.</p>
<p>包名需要尽量指定成唯一的名字, 通常会用公司的域名的颠倒形式(例如 com.yuyin.demo1 ).</p>
<p>包名要和代码路径相匹配. 例如创建 com.bit.demo1 的包, 那么会存在一个对应的路径 com/yuyin/demo1 来存储代码.</p>
<p>如果一个类没有 package 语句, 则该类被放到一个默认包中</p>
</blockquote>
<h2 id="包的访问权限控制"><a href="#包的访问权限控制" class="headerlink" title="包的访问权限控制"></a>包的访问权限控制</h2><blockquote>
<p>我们已经了解了类中的 public 和 private. private 中的成员只能被类的内部使用.</p>
<p>如果某个成员不包含 public 和 private 关键字, 此时这个成员可以在包内部的其他类使用, 但是不能在包外部的类使用.</p>
</blockquote>
<p>下面的代码给了一个示例. Demo1 和 Demo2 是同一个包中, Test 是其他包中.</p>
<p>Demo1.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuyin.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>Demo2.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuyin.demo; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		Demo1 demo = <span class="keyword">new</span> Demo1(); </span><br><span class="line"> 		System.out.println(demo.value); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果, 能够访问到 value 变量</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>Test.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yuyin.demo.Demo1; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		Demo1 demo = <span class="keyword">new</span> Demo1(); </span><br><span class="line"> 		System.out.println(demo.value); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">5</span>, <span class="number">32</span>) java: value在com.yuin.demo.Demo1中不是公共的; 无法从外部程序包中对其进行访问</span><br></pre></td></tr></table></figure>



<h2 id="常见的系统包"><a href="#常见的系统包" class="headerlink" title="常见的系统包"></a>常见的系统包</h2><ol>
<li><p><code>java.lang</code>:系统常用基础类(String、Object),此包从JDK1.1后自动导入。</p>
</li>
<li><p><code>java.lang.reflflect</code>:java 反射编程包;</p>
</li>
<li><p><code>java.net</code>:进行网络编程开发包。</p>
</li>
<li><p><code>java.sql</code>:进行数据库开发的支持包。</p>
</li>
<li><p><code>java.util</code>:是java提供的工具程序包。(集合类等) <strong>非常重要</strong></p>
</li>
<li><p><code>java.io</code>:I/O编程开发包</p>
</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>代码中创建的类, 主要是为了抽象现实中的一些事物(包含属性和方法).</p>
<p>有的时候客观事物之间就存在一些关联关系, 那么在表示成类和对象的时候也会存在一定的关联.</p>
<p>例如, 设计一个类表示动物</p>
<blockquote>
<p> 我们可以给每个类创建一个单独的 java 文件. 类名必须和 .java 文件名匹配(大小写敏感)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">public</span> String name; </span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">public</span> String name; </span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line"></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">public</span> String name; </span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码我们发现其中存在了大量的冗余代码.</p>
<p>仔细分析, 我们发现 <code>Animal</code> 和 <code>Cat</code> 以及 <code>Bird</code> 这几个类中存在一定的关联关系:</p>
<blockquote>
<p>这三个类都具备一个相同的 eat 方法, 而且行为是完全一样的.</p>
<p>这三个类都具备一个相同的 name 属性, 而且意义是完全一样的.</p>
<p>从逻辑上讲, Cat 和 Bird 都是一种 Animal (is - a 语义).</p>
</blockquote>
<p>此时我们就可以让 Cat 和 Bird 分别继承 Animal 类, 来达到代码重用的效果.</p>
<p>此时, Animal 这样被继承的类, 我们称为 <strong>父类</strong> , <strong>基类</strong> 或 <strong>超类</strong>, 对于像 Cat 和 Bird 这样的类, 我们称为 <strong>子类</strong>, <strong>派生类</strong></p>
<p>和现实中的儿子继承父亲的财产类似, 子类也会继承父类的字段和方法, 以达到代码重用的效果</p>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p><strong>基本语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 extends 指定父类.</p>
<p>Java 中一个子类只能继承一个父类 (而C++/Python等语言支持多继承).单继承</p>
<p>子类会继承父类的所有 public 的字段和方法.</p>
<p>对于父类的 private 的字段和方法, 子类中是无法访问的.</p>
<p>子类的实例中, 也包含着父类的实例. 可以使用 super 关键字得到父类实例的引用</p>
</blockquote>
<p>对于上面的代码, 可以使用继承进行改进. 此时我们让 Cat 和 Bird 继承自 Animal 类, 那么 Cat 在定义的时候就不必再写 name 字段和 eat 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  <span class="comment">//父类</span></span><br><span class="line"> 	<span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; 	<span class="comment">//子类</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="comment">// 使用 super 调用父类的构造方法. </span></span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">//子类</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;小黑&quot;</span>); </span><br><span class="line"> 		cat.eat(<span class="string">&quot;猫粮&quot;</span>); </span><br><span class="line"> 		Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>); </span><br><span class="line"> 		bird.fly(); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>extends 英文原意指 “扩展”. 而我们所写的类的继承, 也可以理解成基于父类进行代码上的 “扩展”.</p>
<p>例如我们写的 Bird 类, 就是在 Animal 的基础上扩展出了 flfly 方法</p>
</blockquote>
<p>如果我们把 name 改成 private, 那么此时子类就不能访问了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">19</span>, <span class="number">32</span>) java: name 在 Animal 中是 <span class="keyword">private</span> 访问控制</span><br></pre></td></tr></table></figure>



<h2 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h2><p>刚才我们发现, 如果把字段设为 private, 子类不能访问. 但是设成 public, 又违背了我们 “封装” 的初衷.</p>
<p>两全其美的办法就是 protected 关键字.</p>
<blockquote>
<p>对于类的调用者来说, protected 修饰的字段和方法是不能访问的</p>
<p>对于类的 <strong>子类</strong> 和 <strong>同一个包的其他类</strong> 来说, protected 修饰的字段和方法是可以访问的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">protected</span> String name; </span><br><span class="line"> 	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		<span class="comment">// 对于父类的 protected 字段, 子类可以正确访问</span></span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Test.java 和 Animal.java 不在同一个 包 之中了. </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		Animal animal = <span class="keyword">new</span> Animal(<span class="string">&quot;小动物&quot;</span>); </span><br><span class="line"> 		System.out.println(animal.name); <span class="comment">// 此时编译出错, 无法访问 name </span></span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong>: Java 中对于字段和方法共有四种访问权限</p>
<blockquote>
<p>private: 类内部能访问, 类外部不能访问</p>
<p>默认(也叫包访问权限): 类内部能访问, 同一个包中的类可以访问, 其他类不能访问.</p>
<p>protected: 类内部能访问, 子类和同一个包中的类可以访问, 其他类不能访问.</p>
<p>public : 类内部和类的调用者都能访问</p>
</blockquote>
<p>四个访问权限修饰符的对比图：</p>
<table>
<thead>
<tr>
<th>访问权限</th>
<th>类</th>
<th>包</th>
<th>子类</th>
<th>其他包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>对任何人都是可用的</td>
</tr>
<tr>
<td>protect</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>继承的类可以访问以及和private一样的权限</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>包访问权限，即在整个包内均可被访问</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>类内部能访问, 类外部不能访问</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>什么时候下用哪一种呢?</strong></p>
<p>我们希望类要尽量做到 “封装”, 即隐藏内部实现细节, 只暴露出 <strong>必要</strong> 的信息给类的调用者.</p>
<p>因此我们在使用的时候应该尽可能的使用 <strong>比较严格</strong> 的访问权限. 例如如果一个方法能用 private, 就尽量不要用public.</p>
<p>另外, 还有一种 <strong>简单粗暴</strong> 的做法: 将所有的字段设为 private, 将所有的方法设为 public. 不过这种方式属于是对访问权限的滥用, 还是更希望同学们能写代码的时候认真思考, 该类提供的字段方法到底给 “谁” 使用(是类内部自己用, 还是类的调用者使用, 还是子类使用)</p>
</blockquote>
<h2 id="更复杂的继承关系"><a href="#更复杂的继承关系" class="headerlink" title="更复杂的继承关系"></a>更复杂的继承关系</h2><blockquote>
<p>之前所有的例子都是直接继承的，但是现实中有许多的间接继承，例如动物有猫，狗，但是猫也分许多的种类，布偶，橘猫，然后细分的话又会有许多的子类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> Animal &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat.java </span></span><br><span class="line"><span class="keyword">public</span> Cat extends Animal &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ChineseGardenCat.java </span></span><br><span class="line"><span class="keyword">public</span> ChineseGardenCat extends Cat &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// OrangeCat.java </span></span><br><span class="line"><span class="keyword">public</span> Orange extends ChineseGardenCat &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>如刚才这样的继承方式称为多层继承, 即子类还可以进一步的再派生出新的子类.</p>
<blockquote>
<p>时刻牢记, 我们写的类是现实事物的抽象. 而我们真正在公司中所遇到的项目往往业务比较复杂, 可能会涉及到一系列复杂的概念, 都需要我们使用代码来表示, 所以我们真实项目中所写的类也会有很多. 类之间的关系也会更加复杂.</p>
<p>但是即使如此, 我们并不希望类之间的继承层次太复杂. 一般我们不希望出现超过三层的继承关系. 如果继承层次太多, 就需要考虑对代码进行重构了.</p>
<p>如果想从语法上进行限制继承, 就可以使用 fifinal 关键字</p>
</blockquote>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>曾经我们学习过 final 关键字, 修饰一个变量或者字段的时候, 表示 <strong>常量</strong> (不能修改).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>

<p>final 关键字也能修饰类, 此时表示被修饰的类就不能被继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">3</span>, <span class="number">27</span>) java: 无法从最终com.yuyin.Animal进行继承</span><br></pre></td></tr></table></figure>

<blockquote>
<p>final 关键字的功能是 <strong>限制</strong> 类被继承</p>
<p>“限制” 这件事情意味着 “不灵活”. 在编程中, 灵活往往不见得是一件好事. 灵活可能意味着更容易出错.</p>
<p>是用 final 修饰的类被继承的时候, 就会编译报错, 此时就可以提示我们这样的继承是有悖这个类设计的初衷的.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202112031404230.png" alt="image-20211203140421155"></p>
<p>我们平时是用的 String 字符串类, 就是用 final 修饰的, 不能被继承</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>在刚才的例子里，我们写了如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同时这个代码可以写成如下样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br><span class="line">Animal bird2=bird;</span><br><span class="line"><span class="comment">//或者如下</span></span><br><span class="line">Animal bird2 = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时的Bird2就是父类的引用指向子类的对象，这种写法叫做向上转型</p>
<blockquote>
<p>向上转型这样的写法结合is-a语义来理解</p>
<p>圆圆是一只鸟，但它确实是一个动物</p>
</blockquote>
<p>向上转型发生的时机:</p>
<blockquote>
<p>直接赋值</p>
<p>方法传参</p>
<p>方法返回</p>
</blockquote>
<p><strong>方法传参</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br><span class="line">       	feed( bird);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.eat(<span class="string">&quot;吃谷子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">圆圆正在吃谷子</span><br></pre></td></tr></table></figure>

<p>此时形参 animal 的类型是 Animal (基类), 实际上对应到 Bird (子类) 的实例</p>
<p><strong>方法返回</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Animal animal=findMyAnimal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">findMyAnimal</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> bird;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时方法 <code>findMyAnimal</code> 返回的是一个 Animal 类型的引用, 但是实际上对应到 Bird 的实例.</p>
<h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>当子类和父类中出现同名方法的时候, 再去调用会出现什么情况呢?</p>
<p>对前面的代码稍加修改, 给 Bird 类也加上同名的 eat 方法, 并且在两个 eat 中分别加上不同的日志.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">protected</span> String name; </span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;我是一只小动物&quot;</span>); </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;我是一只小鸟&quot;</span>); </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		Animal animal1 = <span class="keyword">new</span> Animal(<span class="string">&quot;圆圆&quot;</span>); </span><br><span class="line"> 		animal1.eat(<span class="string">&quot;谷子&quot;</span>); </span><br><span class="line"> 		Animal animal2 = <span class="keyword">new</span> Bird(<span class="string">&quot;扁扁&quot;</span>); </span><br><span class="line"> 		animal2.eat(<span class="string">&quot;谷子&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我是一只小动物</span><br><span class="line">圆圆正在吃谷子</span><br><span class="line">我是一只小鸟</span><br><span class="line">扁扁正在吃谷子</span><br></pre></td></tr></table></figure>

<p>此时, 我们发现:</p>
<blockquote>
<p>animal1 和 animal2 虽然都是 Animal 类型的引用, 但是 animal1 指向 Animal 类型的实例, animal2 指向Bird 类型的实例.</p>
<p>针对 animal1 和 animal2 分别调用 eat 方法, 发现 animal1.eat() 实际调用了父类的方法, 而animal2.eat() 实际调用了子类的方法.</p>
</blockquote>
<p>因此, 在 Java 中, 调用某个类的方法, 究竟执行了哪段代码 (是父类方法的代码还是子类方法的代码) , 要看究竟这个引用指向的是父类对象还是子类对象. 这个过程是程序运行时决定的(而不是编译期), 因此称为 <strong>动态绑定</strong>.</p>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>针对刚才的 eat 方法来说:</p>
<p>子类实现父类的同名方法, 并且参数的类型和个数完全相同, 这种情况称为 <strong>覆写重写/覆盖(Override).</strong></p>
<p><strong>关于重写的注意事项</strong></p>
<ol>
<li>重写和重载完全不一样. 不要混淆</li>
<li>普通方法可以重写, static 修饰的静态方法不能重写.</li>
<li>重写中子类的方法的访问权限不能低于父类的方法访问权限.</li>
<li>重写的方法返回值类型不一定和父类的方法相同(但是建议最好写成相同, 特殊情况除外).</li>
</ol>
<p>重载和重写的区别：</p>
<p><strong>方法重载的规则：</strong></p>
<ul>
<li>方法名一致，参数列表中参数的顺序，类型，个数不同。</li>
<li>重载与方法的返回值无关，存在于父类和子类，同类中。</li>
<li>可以抛出不同的异常，可以有不同修饰符。</li>
</ul>
<p><strong>方法重写的规则：</strong></p>
<ul>
<li>参数列表、方法名、返回值类型必须完全一致；</li>
<li>构造方法不能被重写；</li>
<li>声明为 final 的方法不能被重写；</li>
<li>声明为 static 的方法不存在重写（重写和多态联合才有意义）；</li>
<li>访问权限不能比父类更低；</li>
<li>重写之后的方法不能抛出更宽泛的异常；</li>
</ul>
<h2 id="理解多态"><a href="#理解多态" class="headerlink" title="理解多态"></a>理解多态</h2><blockquote>
<p>最好理解就是实战</p>
</blockquote>
<p><strong>代码示例</strong>: 打印多种形状</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	<span class="comment">// 啥都不用干</span></span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;○&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;□&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flower</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;♣&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br><span class="line">====================================</span><br><span class="line"><span class="comment">// Test.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		Shape shape1 = <span class="keyword">new</span> Flower(); </span><br><span class="line"> 		Shape shape2 = <span class="keyword">new</span> Cycle(); </span><br><span class="line"> 		Shape shape3 = <span class="keyword">new</span> Rect(); </span><br><span class="line"> 		drawMap(shape1); </span><br><span class="line"> 		drawMap(shape2); </span><br><span class="line"> 		drawMap(shape3); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="comment">// 打印单个图形</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape shape)</span> </span>&#123; </span><br><span class="line"> 		shape.draw(); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码中, 分割线上方的代码是 <strong>类的实现者</strong> 编写的, 分割线下方的代码是 <strong>类的调用者</strong> 编写的.</p>
<p>当类的调用者在编写 <code>drawMap</code> 这个方法的时候, 参数类型为 Shape (父类), 此时在该方法内部并<strong>不知道,<strong>也</strong>不关注</strong>当前的 shape 引用指向的是哪个类型(哪个子类)的实例. 此时 shape 这个引用调用 draw 方法可能会有多种不同的表现(和 shape 对应的实例相关), 这种行为就称为<strong>多态</strong>.</p>
<blockquote>
<p>多态顾名思义, 就是 “一个引用, 能表现出多种不同形态”</p>
</blockquote>
<p><strong>使用多态的好处是什么?</strong></p>
<p><strong>1)</strong> <strong>类调用者对类的使用成本进一步降低.</strong></p>
<p>封装是让类的调用者不需要知道类的实现细节.</p>
<p>多态能让类的调用者连这个类的类型是什么都不必知道, 只需要知道这个对象具有某个方法即可.</p>
<p>因此, 多态可以理解成是封装的更进一步, 让类调用者对类的使用成本进一步降低.</p>
<p>这也贴合了 &lt;&lt;代码大全&gt;&gt; 中关于 “管理代码复杂程度” 的初衷.</p>
<p><strong>2)</strong> <strong>能够降低代码的</strong> <strong>“圈复杂度”,</strong> <strong>避免使用大量的</strong> <strong>if - else</strong></p>
<p>例如我们现在需要打印的不是一个形状了, 而是多个形状. 如果不基于多态, 实现代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawShapes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	Rect rect = <span class="keyword">new</span> Rect(); </span><br><span class="line"> 	Cycle cycle = <span class="keyword">new</span> Cycle(); </span><br><span class="line"> 	Flower flower = <span class="keyword">new</span> Flower(); </span><br><span class="line"> 	String[] shapes = &#123;<span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;rect&quot;</span>, <span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;rect&quot;</span>, <span class="string">&quot;flower&quot;</span>&#125;; </span><br><span class="line"> </span><br><span class="line"> 	<span class="keyword">for</span> (String shape : shapes) &#123; </span><br><span class="line"> 		<span class="keyword">if</span> (shape.equals(<span class="string">&quot;cycle&quot;</span>)) &#123; </span><br><span class="line"> 			cycle.draw(); </span><br><span class="line"> 		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equals(<span class="string">&quot;rect&quot;</span>)) &#123; </span><br><span class="line"> 			rect.draw(); </span><br><span class="line"> 		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equals(<span class="string">&quot;flower&quot;</span>)) &#123; </span><br><span class="line"> 			flower.draw(); </span><br><span class="line"> 		&#125; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用使用多态, 则不必写这么多的 if - else 分支语句, 代码更简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawShapes</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 	<span class="comment">// 我们创建了一个 Shape 对象的数组. </span></span><br><span class="line"> 	Shape[] shapes = &#123;<span class="keyword">new</span> Cycle(), <span class="keyword">new</span> Rect(), <span class="keyword">new</span> Cycle(), </span><br><span class="line"> 		<span class="keyword">new</span> Rect(), <span class="keyword">new</span> Flower()&#125;; </span><br><span class="line"> 	<span class="keyword">for</span> (Shape shape : shapes) &#123; </span><br><span class="line"> 		shape.draw(); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么叫 “圈复杂度” ?</p>
<p>圈复杂度是一种描述一段代码复杂程度的方式. 一段代码如果平铺直叙, 那么就比较简单容易理解. 而如果有很多的条件分支或者循环语句, 就认为理解起来更复杂.</p>
<p>因此我们可以简单粗暴的计算一段代码中条件语句和循环语句出现的个数, 这个个数就称为 “圈复杂度”. 如果一个方法的圈复杂度太高, 就需要考虑重构.</p>
<p>不同公司对于代码的圈复杂度的规范不一样. 一般不会超过 10</p>
</blockquote>
<p><strong>3)</strong> <strong>可扩展能力更强</strong><strong>.</strong></p>
<p>如果要新增一种新的形状, 使用多态的方式代码改动成本也比较低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;△&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对于类的调用者来说(<code>drawShape</code>s方法), 只要创建一个新类的实例就可以了, 改动成本很低.</p>
<p>而对于不用多态的情况, 就要把 <code>drawShapes</code> 中的 if - else 进行一定的修改, 改动成本更高</p>
<h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>向上转型是子类对象转成父类对象, 向下转型就是父类对象转成子类对象. 相比于向上转型来说, 向下转型没那么常见,但是也有一定的用途</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">protected</span> String name; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;我是一只小动物&quot;</span>); </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;我是一只小鸟&quot;</span>); </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞&quot;</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是我们熟悉的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>); </span><br><span class="line">animal.eat(<span class="string">&quot;谷子&quot;</span>); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">圆圆正在吃谷子</span><br></pre></td></tr></table></figure>

<p>接下来我们尝试让圆圆飞起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animal.fly(); </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">找不到 fly 方法</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<p>编译过程中, animal 的类型是 Animal, 此时编译器只知道这个类中有一个 eat 方法, 没有 fly 方法.</p>
<p>虽然 animal 实际引用的是一个 Bird 对象, 但是编译器是以 animal 的类型来查看有哪些方法的.</p>
<p>对于 <code>Animal animal = new Bird(&quot;圆圆&quot;)</code> 这样的代码,</p>
<blockquote>
<p>编译器检查有哪些方法存在, 看的是 Animal 这个类型</p>
<p>执行时究竟执行父类的方法还是子类的方法, 看的是 Bird 这个类型.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (Bird) 表示强制类型转换</span></span><br><span class="line">Bird bird = (Bird)animal; </span><br><span class="line">bird.fly(); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">圆圆正在飞</span><br></pre></td></tr></table></figure>

<p>但是这样的向下转型有时是不太可靠的. 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat(<span class="string">&quot;小猫&quot;</span>); </span><br><span class="line">Bird bird = (Bird)animal; </span><br><span class="line">bird.fly(); </span><br><span class="line"><span class="comment">// 执行结果, 抛出异常</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Cat cannot be cast to Bird </span><br><span class="line"> at Test.main(Test.java:<span class="number">35</span>) </span><br></pre></td></tr></table></figure>

<p>animal 本质上引用的是一个 Cat 对象, 是不能转成 Bird 对象的. 运行时就会抛出异常</p>
<p>所以, 为了让向下转型更安全, 我们可以先判定一下看看 animal 本质上是不是一个 Bird 实例, 再来转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat(<span class="string">&quot;小猫&quot;</span>); </span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird) &#123; </span><br><span class="line"> 	Bird bird = (Bird)animal; </span><br><span class="line"> 	bird.fly(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instanceof </code>可以判定一个引用是否是某个类的实例. 如果是, 则返回 true. 这时再进行向下转型就比较安全了</p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>前面的代码中由于使用了重写机制, 调用到的是子类的方法. 如果需要在子类内部调用父类方法怎么办? 可以使用</p>
<p>super 关键字.</p>
<p><strong>super</strong> <strong>表示获取到父类实例的引用</strong>. 涉及到两种常见用法.</p>
<ol>
<li>使用了 super 来调用父类的构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 super 来调用父类的普通方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> 		<span class="comment">// 修改代码, 让子调用父类的接口. </span></span><br><span class="line"> 		<span class="keyword">super</span>.eat(food); </span><br><span class="line"> 		System.out.println(<span class="string">&quot;我是一只小鸟&quot;</span>); </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码中, 如果在子类的 eat 方法中直接调用 eat (不加super), 那么此时就认为是调用子类自己的 eat (也就是递归了). 而加上 super 关键字, 才是调用父类的方法.</p>
<p>注意 super 和 this 功能有些相似, 但是还是要注意其中的区别</p>
<table>
<thead>
<tr>
<th align="center">No</th>
<th align="center">区别</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">概念</td>
<td align="center">访问本类中的属性和方法</td>
<td align="center">由子类访问父类中的属性和方法</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">查找范围</td>
<td align="center">先查找本类，如果本类没有就调用父类</td>
<td align="center">不查找本类而直接带哦用不累定义</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">特殊</td>
<td align="center">表示当前类</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h2 id="在构造方法中调用重写的方法-一个坑"><a href="#在构造方法中调用重写的方法-一个坑" class="headerlink" title="在构造方法中调用重写的方法(一个坑)"></a>在构造方法中调用重写的方法(一个坑)</h2><p>一段有坑的代码. 我们创建两个类, B 是父类, D 是子类. D 中重写 <code>func</code> 方法. 并且在 B 的构造方法中调用 <code>func</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		<span class="comment">// do nothing </span></span><br><span class="line"> 		func(); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;B.func()&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;D.func() &quot;</span> + num); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		D d = <span class="keyword">new</span> D();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">D.func() <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造 D 对象的同时, 会调用 B 的构造方法.</p>
<p>B 的构造方法中调用了 func 方法, 此时会触发动态绑定, 会调用到 D 中的 func</p>
<p>此时 D 对象自身还没有构造, 此时 num 处在未初始化的状态, 值为 0.</p>
</blockquote>
<p><strong>结论</strong>: “用尽量简单的方式使对象进入可工作状态”, 尽量不要在构造器中调用方法(如果这个方法被子类重写, 就会触发动态绑定, 但是此时子类对象还没构造完成), 可能会出现一些隐藏的但是又极难发现的问题.</p>
<p><strong>总结</strong></p>
<p>多态是面向对象程序设计中比较难理解的部分. 我们会在后面的抽象类和接口中进一步体会多态的使用. 重点是多态带来的编码上的好处.</p>
<p>另一方面, 如果抛开 Java, 多态其实是一个更广泛的概念, 和 “继承” 这样的语法并没有必然的联系.</p>
<blockquote>
<p>C++ 中的 “动态多态” 和 Java 的多态类似. 但是 C++ 还有一种 “静态多态”(模板), 就和继承体系没有关系了.</p>
<p>Python 中的多态体现的是 “鸭子类型”, 也和继承体系没有关系.</p>
<p>Go 语言中没有 “继承” 这样的概念, 同样也能表示多态.</p>
</blockquote>
<p>无论是哪种编程语言, 多态的核心都是让调用者<strong>不必关注对象的具体类型</strong>. 这是降低用户使用成本的一种重要方式</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h2><p>在刚才的打印图形例子中, 我们发现, 父类 Shape 中的 draw 方法好像并没有什么实际工作, 主要的绘制图形都是由Shape 的各种子类的 draw 方法来完成的. 像这种没有实际工作的方法, 我们可以把它设计成一个 <strong>抽象方法(abstractmethod)</strong>, 包含抽象方法的类我们称为<strong>抽象类(abstract class)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 draw 方法前加上 abstract 关键字, 表示这是一个抽象方法. 同时抽象方法没有方法体(没有 { }, 不能执行具体代码).</p>
<p>对于包含抽象方法的类, 必须加上 abstract 关键字表示这是一个抽象类.</p>
</blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li>抽象类不能直接实例化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape shape = <span class="keyword">new</span> Shape(); </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">30</span>, <span class="number">23</span>) java: Shape是抽象的; 无法实例化</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>抽象方法不能是 private 的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">abstract</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">4</span>, <span class="number">27</span>) java: 非法的修饰符组合: <span class="keyword">abstract</span>和<span class="keyword">private</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象类是不能够实例化的，如果实例方法是private类型，那么其方法就没有创造的意义</p>
</blockquote>
<ol start="3">
<li><p>抽象类中可以包含其他的非抽象方法, 也可以包含字段. 这个非抽象方法和普通方法的规则都是一样的, 可以被重写,也可以被子类直接调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;func&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> 	... </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		Shape shape = <span class="keyword">new</span> Rect(); </span><br><span class="line"> 		shape.func(); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">func</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h2><p>抽象类存在的最大意义就是<strong>为了被继承.</strong></p>
<p>抽象类本身<strong>不能被实例化</strong>, 要想使用, 只能创建该抽象类的子类. 然后让<strong>子类重写抽象类中的抽象方法</strong>.</p>
<blockquote>
<p> 疑问：普通的类也可以被继承呀, 普通的方法也可以被重写呀, 为啥非得用抽象类和抽象方法呢?</p>
</blockquote>
<p>确实如此. 但是使用抽象类相当于多了一重编译器的校验.</p>
<p>使用抽象类的场景就如上面的代码, 实际工作不应该由父类完成, 而应由子类完成. 那么此时如果不小心误用成父类了,</p>
<p>使用普通类编译器是不会报错的. 但是父类是抽象类就会在实例化的时候提示错误, 让我们尽早发现问题.</p>
<blockquote>
<p>很多语法存在的意义都是为了 “预防出错”, 例如我们曾经用过的 final 也是类似. 创建的变量用户不去修改, 不就相当于常量嘛? 但是加上 final 能够在不小心误修改的时候, 让编译器及时提醒我们.</p>
<p>充分利用编译器的校验, 在实际开发中是非常有意义的</p>
</blockquote>
<p>抽象类的大总结：</p>
<blockquote>
<ol>
<li>包含抽象方法的类，叫做抽象类</li>
<li>什么是抽象类，一个没有具体实现的方法，被abstract修饰。</li>
<li>抽象类是不可以被实例化的。</li>
<li>因为不可以被实例化，所以抽象类只能被继承。</li>
<li>抽象类中，也可以包含和普通类一样的成员和方法。</li>
<li>一个普通类，继承了一个抽象类，那么这个普通类必须重写抽象类中所有的抽象方法。</li>
<li>抽象类最大的作用就是被继承。</li>
<li>一个抽象类A，如果继承了一个抽象类B，那么这个抽象类A，可以不实现父类B的抽象方法。</li>
<li>结合第8点，当A类再次被一个普通类继承后，那么A和B这两个类中所有的抽象方法，必须被重写。</li>
<li>抽象列不能被final修饰，抽象方法也不可以被final修饰。</li>
</ol>
</blockquote>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是抽象类的更进一步. 抽象类中还可以包含非抽象方法, 和字段. 而接口中包含的<strong>方法都是抽象方法</strong>, <strong>字段只能包含静态常量</strong>.</p>
<h2 id="语法规则-2"><a href="#语法规则-2" class="headerlink" title="语法规则"></a>语法规则</h2><p>在刚才的打印图形的示例中, 我们的父类 Shape 并没有包含别的非抽象方法, 也可以设计成一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IShape</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;  <span class="comment">//完整就是abstract public void draw();</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> <span class="keyword">implements</span> <span class="title">IShape</span> </span>&#123; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="string">&quot;○&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> 		IShape shape = <span class="keyword">new</span> Rect(); </span><br><span class="line"> 		shape.draw(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 interface 定义一个接口</p>
<p>接口中的方法一定是抽象方法, 因此可以省略 abstract</p>
<p>接口中的方法一定是 public, 因此可以省略 public</p>
<p>Cycle 使用 implements 继承接口. 此时表达的含义不再是 “扩展”, 而是 “实现”</p>
<p>在调用的时候同样可以创建一个接口的引用, 对应到一个子类的实例.</p>
<p>接口不能单独被实例化</p>
</blockquote>
<blockquote>
<p>扩展(extends) vs 实现(implements)</p>
<p>扩展指的是当前已经有一定的功能了, 进一步扩充功能.</p>
<p>实现指的是当前啥都没有, 需要从头构造出来</p>
</blockquote>
<p>接口中只能包含抽象方法. 对于字段来说, 接口中只能包含静态常量(final static).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IShape</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 public, static, final 的关键字都可以省略. 省略后的 <code>num</code> 仍然表示 public 的静态常量.</p>
<blockquote>
<p>提示:</p>
<ol>
<li><p>我们创建接口的时候, 接口的命名一般以大写字母 I 开头.</p>
</li>
<li><p>接口的命名一般使用 “形容词” 词性的单词.</p>
</li>
<li><p>阿里编码规范中约定, 接口中的方法和属性不要加任何修饰符号, 保持代码的简洁性</p>
</li>
</ol>
</blockquote>
<h2 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h2><p>有的时候我们需要让一个类同时继承自多个父类. 这件事情在有些编程语言通过 <strong>多继承</strong> 的方式来实现的.</p>
<p>然而 Java 中只支持单继承, 一个类只能 extends 一个父类. 但是可以同时实现多个接口, 也能达到多继承类似的效果.</p>
<p>现在我们通过类来表示一组动物.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">protected</span> String name; </span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外我们再提供一组接口, 分别表示 “会飞的”, “会跑的”, “会游泳的”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFlying</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们创建几个具体的动物</p>
<p>猫, 是会跑的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">	 <span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用四条腿跑&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鱼, 是会游的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用尾巴游泳&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>青蛙, 既能跑, 又能游(两栖动物)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">IRunning</span>, <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Frog</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在往前跳&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在蹬腿游泳&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种神奇的动物, 水陆空三栖, 叫做 “鸭子”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">IRunning</span>, <span class="title">ISwimming</span>, <span class="title">IFlying</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">super</span>(name); </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用翅膀飞&quot;</span>); </span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用两条腿跑&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">    </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在漂在水上&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了 Java 面向对象编程中最常见的用法: 一个类继承一个父类, 同时实现多种接口.</p>
<p>继承表达的含义是 <code>is - a</code> 语义, 而接口表达的含义是 具有 <code>xxx</code> 特性</p>
<blockquote>
<p>猫是一种动物, 具有会跑的特性.</p>
<p>青蛙也是一种动物, 既能跑, 也能游泳</p>
<p>鸭子也是一种动物, 既能跑, 也能游, 还能飞</p>
</blockquote>
<p>这样设计有什么好处呢? 时刻牢记多态的好处, 让程序猿<strong>忘记类型</strong>. 有了接口之后, 类的使用者就不必关注具体类型, 而只关注某个类是否具备某种能力.</p>
<p>例如, 现在实现一个方法, 叫 “散步”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(IRunning running)</span> </span>&#123; </span><br><span class="line"> 	System.out.println(<span class="string">&quot;我带着伙伴去散步&quot;</span>); </span><br><span class="line"> 	running.run(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个 walk 方法内部, 我们并不关注到底是哪种动物, 只要参数是会跑的, 就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;小猫&quot;</span>); </span><br><span class="line">walk(cat); </span><br><span class="line">Frog frog = <span class="keyword">new</span> Frog(<span class="string">&quot;小青蛙&quot;</span>); </span><br><span class="line">walk(frog); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我带着伙伴去散步</span><br><span class="line">小猫正在用四条腿跑</span><br><span class="line">我带着伙伴去散步</span><br><span class="line">小青蛙正在往前跳</span><br></pre></td></tr></table></figure>

<p>甚至参数可以不是 “动物”, 只要会跑!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">private</span> String name; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用轮子跑&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line">	Robot robot = <span class="keyword">new</span> Robot(<span class="string">&quot;机器人&quot;</span>); </span><br><span class="line">	walk(robot); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">机器人正在用轮子跑</span><br></pre></td></tr></table></figure>



<h2 id="接口使用实例"><a href="#接口使用实例" class="headerlink" title="接口使用实例"></a>接口使用实例</h2><p><strong>给对象数组排序</strong></p>
<p>给定一个学生类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">private</span> String name; </span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">int</span> score; </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 		<span class="keyword">this</span>.score = score; </span><br><span class="line"> 	&#125; </span><br><span class="line"> </span><br><span class="line"> 	<span class="meta">@Override</span> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.score + <span class="string">&quot;]&quot;</span>; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再给定一个学生对象数组, 对这个对象数组中的元素进行排序(按分数降序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = <span class="keyword">new</span> Student[] &#123; </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">95</span>), </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">96</span>), </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>, <span class="number">97</span>), </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;赵六&quot;</span>, <span class="number">92</span>), </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>按照我们之前的理解, 数组我们有一个现成的 sort 方法, 能否直接使用这个方法呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students); </span><br><span class="line">System.out.println(Arrays.toString(students)); </span><br><span class="line"><span class="comment">// 运行出错, 抛出异常. </span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Student cannot be cast to java.lang.Comparable</span><br></pre></td></tr></table></figure>

<p>仔细思考, 不难发现, 和普通的整数不一样, 两个整数是可以直接比较的, 大小关系明确. 而两个学生对象的大小关系怎么确定? 需要我们额外指定.</p>
<p>让我们的 Student 类实现 <code>Comparable</code> 接口, 并实现其中的 <code>compareTo</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Comparable &#123; </span><br><span class="line"> 	private String name; </span><br><span class="line"> 	private int score; </span><br><span class="line"> 	public Student(String name, int score) &#123; </span><br><span class="line"> 		this.name = name; </span><br><span class="line"> 		this.score = score; </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	@Override</span><br><span class="line">  	public String toString() &#123; </span><br><span class="line"> 		return &quot;[&quot; + this.name + &quot;:&quot; + this.score + &quot;]&quot;; </span><br><span class="line"> 	&#125; </span><br><span class="line"> 	@Override </span><br><span class="line"> 	public int compareTo(Object o) &#123; </span><br><span class="line"> 		Student s = (Student)o; </span><br><span class="line"> 		if (this.score &gt; s.score) &#123; </span><br><span class="line"> 			return -1; </span><br><span class="line"> 		&#125; else if (this.score &lt; s.score) &#123; </span><br><span class="line"> 			return 1; </span><br><span class="line"> 		&#125; else &#123; </span><br><span class="line"> 			return 0; </span><br><span class="line"> 		&#125; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 sort 方法中会自动调用 <code>compareTo</code> 方法. <code>compareTo</code> 的参数是 Object , 其实传入的就是 Student 类型的对象.</p>
<p>然后比较当前对象和参数对象的大小关系(按分数来算).</p>
<blockquote>
<p>如果当前对象应排在参数对象之前, 返回小于 0 的数字;</p>
<p>如果当前对象应排在参数对象之后, 返回大于 0 的数字;</p>
<p>如果当前对象和参数对象不分先后, 返回 0;</p>
</blockquote>
<p>再次执行程序, 结果就符合预期了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">[[王五:<span class="number">97</span>], [李四:<span class="number">96</span>], [张三:<span class="number">95</span>], [赵六:<span class="number">92</span>]]</span><br></pre></td></tr></table></figure>



<h2 id="接口间的继承"><a href="#接口间的继承" class="headerlink" title="接口间的继承"></a>接口间的继承</h2><p>接口可以继承一个接口, 达到复用的效果. 使用 extends 关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 两栖的动物, 既能跑, 也能游</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAmphibious</span> <span class="keyword">extends</span> <span class="title">IRunning</span>, <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">implements</span> <span class="title">IAmphibious</span> </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过接口继承创建一个新的接口 <code>IAmphibious</code> 表示 “两栖的”. 此时实现接口创建的 Frog 类, 就继续要实现 run 方法,也需要实现 swim 方法.</p>
<blockquote>
<p>接口间的继承相当于把多个接口合并在一起</p>
</blockquote>
<p>接口的总结：</p>
<blockquote>
<ol>
<li>使用interface来修饰。interface IA{}</li>
<li>接口中的普通方法，不能有具体的实现，非要实现，只能通过关键字default来修饰这个方法。</li>
<li>接口当中，可以有static的方法。</li>
<li>里面所有的方法都是public的</li>
<li>抽象方法，默认是public abstract的</li>
<li>接口不可以通过关键字new来实例化。</li>
<li>类和接口之间的关系式通过<code>implemens</code>实现的</li>
<li>当一个类实现了一个接口，就必须要重写接口当中的抽象方法。</li>
<li>接口当中的成员变量默认是 <code>public static final</code>修饰的</li>
<li>当一个类实现一个接口后，重写这个方法的时候，这个方法前面必须加上public</li>
<li>一个类可以通过关键字extends继承一个抽象类或者普通类，但是只能继承一个类，同时可以用过implements实现多个接口，接口之间用逗号隔开。</li>
</ol>
</blockquote>
<h2 id="Clonable接口和深拷贝"><a href="#Clonable接口和深拷贝" class="headerlink" title="Clonable接口和深拷贝"></a>Clonable接口和深拷贝</h2><p>Java 中内置了一些很有用的接口, Clonable 就是其中之一.</p>
<p>Object 类中存在一个 clone 方法, 调用这个方法可以创建一个对象的 “拷贝”. 但是要想合法调用 clone 方法, 必须要先</p>
<p>实现 Clonable 接口, 否则就会抛出 CloneNotSupportedException 异常.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Animal <span class="title">clone</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> Animal o = <span class="keyword">null</span>; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> o = (Animal)<span class="keyword">super</span>.clone(); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">      e.printStackTrace(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Animal animal = <span class="keyword">new</span> Animal(); </span><br><span class="line"> Animal animal2 = animal.clone(); </span><br><span class="line"> System.out.println(animal == animal2); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>浅拷贝 VS 深拷贝</p>
<p>Cloneable 拷贝出的对象是一份 “浅拷贝”</p>
<p>观察以下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">		<span class="meta">@Override</span> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> A <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">			<span class="keyword">return</span> (A)<span class="keyword">super</span>.clone(); </span><br><span class="line">		&#125; </span><br><span class="line"> &#125; </span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line">		<span class="keyword">public</span> A a = <span class="keyword">new</span> A(); </span><br><span class="line">		<span class="meta">@Override</span> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> B <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">           <span class="keyword">return</span> (B)<span class="keyword">super</span>.clone(); </span><br><span class="line">       &#125; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">		B b = <span class="keyword">new</span> B(); </span><br><span class="line">		B b2 = b.clone(); </span><br><span class="line">		b.a.num = <span class="number">10</span>; </span><br><span class="line">		System.out.println(b2.a.num); </span><br><span class="line">	&#125; </span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;<span class="comment">// 执行结果</span></span><br><span class="line">&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>通过 clone 拷贝出的 b 对象只是拷贝了 b 自身, 而没有拷贝内部包含的 a 对象. 此时 b 和 b2 中包含的 a 引用仍然是指向同一个对象. 此时修改一边, 另一边也会发生改变.</p>
</blockquote>
<p><strong>总结</strong></p>
<p>抽象类和接口都是 Java 中多态的常见使用方式. 都需要重点掌握. 同时又要认清两者的区别(重要!!! 常见面试题).</p>
<p><strong>核心区别</strong>: 抽象类中可以包含普通方法和普通字段, 这样的普通方法和字段可以被子类直接使用(不必重写), 而接口中不能包含普通方法, 子类必须重写所有的抽象方法.</p>
<p>如之前写的 Animal 例子. 此处的 Animal 中包含一个 name 这样的属性, 这个属性在任何子类中都是存在的. 因此此处的 Animal 只能作为一个抽象类, 而不应该成为一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> 	<span class="keyword">protected</span> String name; </span><br><span class="line"> </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> 		<span class="keyword">this</span>.name = name; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>再次提醒:</p>
<p>抽象类存在的意义是为了让编译器更好的校验, 像 Animal 这样的类我们并不会直接使用, 而是使用它的子类. 万一不小心创建了 Animal 的实例, 编译器会及时提醒我们</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">余音</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">http://example.com/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">余音的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252041482.jfif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/12/01/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252042639.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">类和对象</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/04/String%E7%B1%BB%E7%9A%84%E8%AE%A4%E8%AF%86/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252041482.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">String类的认识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111251736783.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">余音</div><div class="author-info__description">余音的博客，欢迎访问</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fishyin" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:785811203@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">导入包中的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%8C%85"><span class="toc-number">1.2.</span> <span class="toc-text">静态导包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A%E7%B1%BB%E6%94%BE%E5%85%A5%E5%8C%85%E4%B8%AD"><span class="toc-number">1.3.</span> <span class="toc-text">把类放入包中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">包的访问权限控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%8C%85"><span class="toc-number">1.5.</span> <span class="toc-text">常见的系统包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">2.2.</span> <span class="toc-text">语法规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.3.</span> <span class="toc-text">protected关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">2.4.</span> <span class="toc-text">更复杂的继承关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.5.</span> <span class="toc-text">final关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">3.2.</span> <span class="toc-text">动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">3.3.</span> <span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A4%9A%E6%80%81"><span class="toc-number">3.4.</span> <span class="toc-text">理解多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">向下转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.6.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95-%E4%B8%80%E4%B8%AA%E5%9D%91"><span class="toc-number">3.7.</span> <span class="toc-text">在构造方法中调用重写的方法(一个坑)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99-1"><span class="toc-number">4.1.</span> <span class="toc-text">语法规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">抽象类的作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99-2"><span class="toc-number">5.1.</span> <span class="toc-text">语法规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.</span> <span class="toc-text">实现多个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.3.</span> <span class="toc-text">接口使用实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">5.4.</span> <span class="toc-text">接口间的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clonable%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.5.</span> <span class="toc-text">Clonable接口和深拷贝</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" title="【Java集合】接口的简单介绍"><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252042119.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Java集合】接口的简单介绍"/></a><div class="content"><a class="title" href="/2022/01/18/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" title="【Java集合】接口的简单介绍">【Java集合】接口的简单介绍</a><time datetime="2022-01-18T08:34:46.000Z" title="发表于 2022-01-18 16:34:46">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/08/LeetCode%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%981/" title="LeetCode数组刷题1"><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252042639.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode数组刷题1"/></a><div class="content"><a class="title" href="/2022/01/08/LeetCode%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%981/" title="LeetCode数组刷题1">LeetCode数组刷题1</a><time datetime="2022-01-08T05:43:44.000Z" title="发表于 2022-01-08 13:43:44">2022-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/07/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="异常处理"><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252042119.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="异常处理"/></a><div class="content"><a class="title" href="/2021/12/07/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="异常处理">异常处理</a><time datetime="2021-12-07T06:32:05.000Z" title="发表于 2021-12-07 14:32:05">2021-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/04/String%E7%B1%BB%E7%9A%84%E8%AE%A4%E8%AF%86/" title="String类的认识"><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252041482.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="String类的认识"/></a><div class="content"><a class="title" href="/2021/12/04/String%E7%B1%BB%E7%9A%84%E8%AE%A4%E8%AF%86/" title="String类的认识">String类的认识</a><time datetime="2021-12-04T02:06:00.000Z" title="发表于 2021-12-04 10:06:00">2021-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" title="面向对象编程"><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/202111252041482.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面向对象编程"/></a><div class="content"><a class="title" href="/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" title="面向对象编程">面向对象编程</a><time datetime="2021-12-03T12:56:27.000Z" title="发表于 2021-12-03 20:56:27">2021-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 余音</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thank you for visiting my blog！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>