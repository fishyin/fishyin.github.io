<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Java集合】ArrayList</title>
      <link href="/2022/01/22/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91ArrayList/"/>
      <url>/2022/01/22/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="关于泛型的小小了解"><a href="#关于泛型的小小了解" class="headerlink" title="关于泛型的小小了解"></a>关于泛型的小小了解</h1><h2 id="泛型的分类"><a href="#泛型的分类" class="headerlink" title="泛型的分类"></a>泛型的分类</h2><blockquote><ol><li><p>泛型类 </p></li><li><p>泛型方法</p></li></ol></blockquote><h2 id="泛型类的定义的简单演示"><a href="#泛型类的定义的简单演示" class="headerlink" title="泛型类的定义的简单演示"></a>泛型类的定义的简单演示</h2><p>关于泛型类的定义，这里只是了解即可，我们重点学习泛型类的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 尖括号 &lt;&gt; 是泛型的标志 </span></span><br><span class="line"><span class="comment">// 2. E 是类型变量(Type Variable)，变量名一般要大写 </span></span><br><span class="line"><span class="comment">// 3. E 在定义时是形参，代表的意思是 MyArrayList 最终传入的类型，但现在还不知道 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> E[] array; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 泛型类可以一次有多个类型变量，用逗号分割。</p><h2 id="泛型类的使用"><a href="#泛型类的使用" class="headerlink" title="泛型类的使用"></a>泛型类的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个元素是 Book 引用的</span></span><br><span class="line">MyArrayList MyArrayList&lt;Book&gt; books = <span class="keyword">new</span> MyArrayList&lt;Book&gt;(); </span><br><span class="line">books.add(<span class="keyword">new</span> Book()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 会产生编译错误，Person 类型无法转换为 Book 类型 </span></span><br><span class="line">books.add(<span class="keyword">new</span> Person()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要做类型转换 </span></span><br><span class="line">Book book = book.get(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要做类型转换 </span></span><br><span class="line"><span class="comment">// 会产生编译错误，Book 类型无法转换为 Person 类型 </span></span><br><span class="line">Person person = book.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>通过以上代码，我们可以看到泛型类的一个使用方式：只需要在所有类型后边跟尖括号，并且尖括号内是真正的类型，即 E 可以看作的最后的类型。</p><p><strong>注意：</strong> Book 只能想象成 E 的类型，但实际上 E 的类型还是 Object</p><h2 id="泛型总结"><a href="#泛型总结" class="headerlink" title="泛型总结"></a>泛型总结</h2><ol><li><p>泛型是为了解决某些容器、算法等代码的通用性而引入，并且能在编译期间做类型检查。</p></li><li><p>泛型利用的是 Object 是所有类的祖先类，并且父类的引用可以指向子类对象的特定而工作。</p></li><li><p>泛型是一种编译期间的机制，即 <code>MyArrayList&lt;Person&gt;</code> 和 <code>MyArrayList&lt;Book&gt;</code> 在运行期间是一个类型。</p></li><li><p>泛型是 java 中的一种合法语法，标志就是尖括号 &lt;&gt;</p></li></ol><h1 id="包装类的认识"><a href="#包装类的认识" class="headerlink" title="包装类的认识"></a>包装类的认识</h1><p>Object引用可以指向任意类型的对象，但有例外出现了，8 种基本数据类型不是对象，那岂不是刚才的泛型机制要失效了？</p><p>实际上也确实如此，为了解决这个问题，java 引入了一类特殊的类，即这 8 种基本数据类型的包装类，在使用过程中，会将类似 <code>int</code> 这样的值包装到一个对象中去。</p><h2 id="基本数据类型和包装类直接的对应关系"><a href="#基本数据类型和包装类直接的对应关系" class="headerlink" title="基本数据类型和包装类直接的对应关系"></a>基本数据类型和包装类直接的对应关系</h2><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>Byte</code></td></tr><tr><td><code>short</code></td><td><code>Short</code></td></tr><tr><td><code>int</code></td><td><code>Integer</code></td></tr><tr><td><code>long</code></td><td><code>Long</code></td></tr><tr><td><code>float</code></td><td><code>Float</code></td></tr><tr><td><code>double</code></td><td><code>Double</code></td></tr><tr><td><code>char</code></td><td><code>Character</code></td></tr><tr><td><code>boolean</code></td><td><code>Boolean</code></td></tr></tbody></table><p>基本上就是类型的首字母大写，除了<code>Integer</code>和<code>Character</code></p><h2 id="包装类的使用，装箱-boxing-和拆箱-unboxing"><a href="#包装类的使用，装箱-boxing-和拆箱-unboxing" class="headerlink" title="包装类的使用，装箱(boxing)和拆箱(unboxing)"></a>包装类的使用，装箱(boxing)和拆箱(unboxing)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 装箱操作，新建一个 Integer 类型对象，将 i 的值放入对象的某个属性中 </span></span><br><span class="line">Integer ii = Integer.valueOf(i); </span><br><span class="line">Integer ij = <span class="keyword">new</span> Integer(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆箱操作，将 Integer 对象中的值取出，放到一个基本数据类型中 </span></span><br><span class="line"><span class="keyword">int</span> j = ii.intValue();</span><br></pre></td></tr></table></figure><h2 id="自动装箱-autoboxing-和自动拆箱-autounboxing"><a href="#自动装箱-autoboxing-和自动拆箱-autounboxing" class="headerlink" title="自动装箱(autoboxing)和自动拆箱(autounboxing)"></a>自动装箱(autoboxing)和自动拆箱(autounboxing)</h2><p>可以看到在使用过程中，装箱和拆箱带来不少的代码量，所以为了减少开发者的负担，java 提供了自动机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">Integer ii = i; <span class="comment">// 自动装箱 </span></span><br><span class="line">Integer ij = (Integer)i; <span class="comment">// 自动装箱 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = ii; <span class="comment">// 自动拆箱 </span></span><br><span class="line"><span class="keyword">int</span> k = (<span class="keyword">int</span>)ii; <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>自动装箱和自动拆箱是工作在编译期间的一种机制。</p><h1 id="List的常用方法"><a href="#List的常用方法" class="headerlink" title="List的常用方法"></a>List的常用方法</h1><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>尾插e</td></tr><tr><td><code>void add(int index, E element) </code></td><td>将e插入到index位置</td></tr><tr><td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td><td>尾插c中元素</td></tr><tr><td><code>E remove(int index) </code></td><td>删除index位置元素</td></tr><tr><td><code>boolean remove(Object o) </code></td><td>删除遇到的第一个o</td></tr><tr><td><code>E get(int index) </code></td><td>获取下标index位置元素</td></tr><tr><td><code>E set(int index, E element) </code></td><td>将下标index位置元素设置为element</td></tr><tr><td><code>void clear()</code></td><td>清空</td></tr><tr><td><code>boolean contains(Object o) </code></td><td>判断o是否在线性表中</td></tr><tr><td><code>int indexOf(Object o)</code></td><td>返回第一个o所在下标</td></tr><tr><td><code>int lastIndexOf(Object o) </code></td><td>返回后最后一个o的下标</td></tr><tr><td><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></td><td>截取部分list</td></tr></tbody></table><h1 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a><code>ArrayList</code>简介</h1><p>在集合框架中，<code>ArrayLis</code>t是一个普通的类，实现了List接口，具体框架图如下</p><p><img src="C:/Users/78581/AppData/Roaming/Typora/typora-user-images/image-20220119233038765.png" alt="image-20220119233038765"></p><blockquote><p>【<strong>说明</strong>】 </p><ol><li><p><code>ArrayList</code>实现了<code>RandomAccess</code>接口，表明<code>ArrayList</code>支持随机访问</p></li><li><p><code>ArrayList</code>实现了Cloneable接口，表明<code>ArrayList</code>是可以clone的 </p></li><li><p><code>ArrayList</code>实现了Serializable接口，表明<code>ArrayList</code>是支持序列化的</p></li><li><p>和Vector不同，<code>ArrayList</code>不是线程安全的，在单线程下可以使用，在多线程中可以选择Vector或者<code>CopyOnWriteArrayList</code></p></li><li><p><code>ArrayList</code>底层是一段连续的空间，并且可以动态扩容，是一个动态类型的顺序表</p></li></ol></blockquote><h1 id="ArrayList使用"><a href="#ArrayList使用" class="headerlink" title="ArrayList使用"></a><code>ArrayList</code>使用</h1><h2 id="ArrayList-的构造"><a href="#ArrayList-的构造" class="headerlink" title="ArrayList 的构造"></a><code>ArrayList</code> 的构造</h2><table><thead><tr><th><strong>方法</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><code>ArrayList() </code></td><td>无参构造</td></tr><tr><td><code>ArrayList(Collection&lt;? extends E&gt; c) </code></td><td>利用其他 Collection 构建 <code>ArrayList</code></td></tr><tr><td><code>ArrayList(int initialCapacity) </code></td><td>指定顺序表初始容量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ArrayList创建，推荐写法 </span></span><br><span class="line">    <span class="comment">// 构造一个空的列表 </span></span><br><span class="line">    List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造一个具有10个容量的列表 </span></span><br><span class="line">    List&lt;Integer&gt;list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>); </span><br><span class="line">    list2.add(<span class="number">1</span>); list2.add(<span class="number">2</span>); </span><br><span class="line">    list2.add(<span class="number">3</span>); /</span><br><span class="line">        / list2.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 编译失败，List&lt;Integer&gt;已经限定了，list2中只能存储整形元素 </span></span><br><span class="line">    <span class="comment">// list3构造好之后，与list中的元素一致 </span></span><br><span class="line">    ArrayList&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;(list2); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 避免省略类型，否则：任意类型的元素都可以存放，使用时将是一场灾难 </span></span><br><span class="line">    List list4 = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">    list4.add(<span class="string">&quot;111&quot;</span>); </span><br><span class="line">    list4.add(<span class="number">100</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList-的常见操作"><a href="#ArrayList-的常见操作" class="headerlink" title="ArrayList 的常见操作"></a><code>ArrayList</code> 的常见操作</h2><p><code>ArrayList</code>虽然提供的方法比较多，但是常用方法如下所示，需要用到其他方法时，自行查看<code>ArrayList</code>的帮助文档。</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>尾插 e</td></tr><tr><td><code>void add(int index, E element)</code></td><td>将 e 插入到 index 位置</td></tr><tr><td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td><td>尾插 c 中的元素</td></tr><tr><td><code>E remove(int index)</code></td><td>删除 index 位置元素</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>删除遇到的第一个 o</td></tr><tr><td><code>E get(int index)</code></td><td>获取下标 index 位置元素</td></tr><tr><td><code>E set(int index, E element) </code></td><td>将下标 index 位置元素设置为 element</td></tr><tr><td><code>void clear() </code></td><td>清空</td></tr><tr><td><code>boolean contains(Object o)</code></td><td>判断 o 是否在线性表中</td></tr><tr><td><code> int indexOf(Object o)</code></td><td>返回第一个 o 所在下标</td></tr><tr><td><code>int lastIndexOf(Object o)</code></td><td>返回最后一个 o 的下标</td></tr><tr><td><code>List&lt;E&gt; subList(int fromIndex, int toIndex) </code></td><td>截取部分 list</td></tr></tbody></table> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    list.add(<span class="string">&quot;JavaSE&quot;</span>); </span><br><span class="line">    list.add(<span class="string">&quot;JavaWeb&quot;</span>); </span><br><span class="line">    list.add(<span class="string">&quot;JavaEE&quot;</span>); </span><br><span class="line">    list.add(<span class="string">&quot;JVM&quot;</span>); </span><br><span class="line">    list.add(<span class="string">&quot;测试&quot;</span>); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取list中有效元素个数 </span></span><br><span class="line">    System.out.println(list.size()); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取和设置index位置上的元素，注意index必须介于[0, size)间 </span></span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>)); </span><br><span class="line">    list.set(<span class="number">1</span>, <span class="string">&quot;JavaWEB&quot;</span>); System.out.println(list.get(<span class="number">1</span>)); </span><br><span class="line">    <span class="comment">// 在list的index位置插入指定元素，index及后续的元素统一往后搬移一个位置 </span></span><br><span class="line">    list.add(<span class="number">1</span>, <span class="string">&quot;Java数据结构&quot;</span>); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">    <span class="comment">// 删除指定元素，找到了就删除，该元素之后的元素统一往前搬移一个位置 </span></span><br><span class="line">    list.remove(<span class="string">&quot;JVM&quot;</span>); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">    <span class="comment">// 删除list中index位置上的元素，注意index不要超过list中有效元素个数,否则会抛出下标越界异常 </span></span><br><span class="line">    list.remove(list.size()-<span class="number">1</span>); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 检测list中是否包含指定元素，包含返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">if</span>(list.contains(<span class="string">&quot;测试&quot;</span>))&#123; </span><br><span class="line">        list.add(<span class="string">&quot;测试&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找指定元素第一次出现的位置：indexOf从前往后找，lastIndexOf从后往前找 </span></span><br><span class="line">    list.add(<span class="string">&quot;JavaSE&quot;</span>); </span><br><span class="line">    System.out.println(list.indexOf(<span class="string">&quot;JavaSE&quot;</span>)); </span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="string">&quot;JavaSE&quot;</span>)); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用list中[0, 4)之间的元素构成一个新的ArrayList返回 </span></span><br><span class="line">    List&lt;String&gt; ret = list.subList(<span class="number">0</span>, <span class="number">4</span>); </span><br><span class="line">    System.out.println(ret); </span><br><span class="line">    list.clear(); </span><br><span class="line">    System.out.println(list.size()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201221635325.png" alt="image-20220122163506958"></p><h2 id="ArrayList-的遍历"><a href="#ArrayList-的遍历" class="headerlink" title="ArrayList 的遍历"></a><code>ArrayList</code> 的遍历</h2><p><code>ArrayList</code> 可以使用三方方式遍历：for循环+下标、<code>foreach</code>、使用迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    list.add(<span class="number">1</span>); </span><br><span class="line">    list.add(<span class="number">2</span>); </span><br><span class="line">    list.add(<span class="number">3</span>); </span><br><span class="line">    list.add(<span class="number">4</span>); </span><br><span class="line">    list.add(<span class="number">5</span>); </span><br><span class="line">    <span class="comment">// 使用下标+for遍历 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123; </span><br><span class="line">        System.out.print(list.get(i) + <span class="string">&quot; &quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(); </span><br><span class="line">    <span class="comment">// 借助foreach遍历 </span></span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123; </span><br><span class="line">        System.out.print(integer + <span class="string">&quot; &quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(); </span><br><span class="line">    <span class="comment">//使用迭代器遍历</span></span><br><span class="line">    Iterator&lt;Integer&gt; it = list.listIterator(); </span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123; </span><br><span class="line">        System.out.print(it.next() + <span class="string">&quot; &quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201221638266.png" alt="image-20220122163838779"></p><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title=" ArrayList的扩容机制"></a><code> ArrayList</code>的扩容机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">        list.add(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code>是一个动态类型的顺序表，即：在插入元素的过程中会自动扩容：以下是<code>ArrayList</code>源码中扩容方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Object[] elementData; <span class="comment">// 存放元素的空间 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; <span class="comment">// 默认空间 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>; <span class="comment">// 默认容量大小 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>); <span class="comment">// Increments modCount!! </span></span><br><span class="line">    elementData[size++] = e; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; </span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; </span><br><span class="line">    modCount++; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// overflow-conscious code </span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>) </span><br><span class="line">        grow(minCapacity); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 获取旧空间大小 </span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预计按照1.5倍方式扩容 </span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果用户需要扩容大小 超过 原空间1.5倍，按照用户所需大小扩容 </span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">        newCapacity = minCapacity; </span><br><span class="line">    <span class="comment">// 如果需要扩容大小超过MAX_ARRAY_SIZE，重新计算容量大小 </span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">newCapacity = hugeCapacity(minCapacity); </span><br><span class="line">    <span class="comment">// 调用copyOf扩容 </span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 如果minCapacity小于0，抛出OutOfMemoryError异常 </span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(); </span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【总结】 <span class="number">1.</span> 检测是否真正需要扩容，如果是调用grow准备扩容</span><br><span class="line"><span class="number">2.</span> 预估需要库容的大小</span><br><span class="line">初步预估按照<span class="number">1.5</span>倍大小扩容</span><br><span class="line">如果用户所需大小超过预估<span class="number">1.5</span>倍大小，则按照用户所需大小扩容</span><br><span class="line">真正扩容之前检测是否能扩容成功，防止太大导致扩容失败</span><br><span class="line"><span class="number">3.</span> 使用copyOf进行扩容</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【Java集合】接口的简单介绍</title>
      <link href="/2022/01/18/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/01/18/%E3%80%90Java%E9%9B%86%E5%90%88%E3%80%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>首先见识一下Java集合框架的大概图例：</p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201181633282.png" alt="image-20220118160723404"></p><p>由图可以看出，集合框架大致分为两部分，接下来分为别简单讲解一下各个部分。</p><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><blockquote><p>Collection ：用来存储管理一组对象 objects ，这些对象一般被成为元素 elements </p><ol><li><p>Set : 元素不能重复，背后隐含着<strong>查找</strong>/<strong>搜索</strong>的语义</p></li><li><p>SortedSet : 一组有序的不能重复的元素</p></li><li><p>List : 线性结构</p></li><li><p>Queue : 队列</p></li><li><p>Deque : 双端队列</p></li></ol></blockquote><h2 id="Collection常用方法说明"><a href="#Collection常用方法说明" class="headerlink" title="Collection常用方法说明"></a>Collection常用方法说明</h2><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>将元素e放入集合中</td></tr><tr><td><code>void clear()</code></td><td>删除集合中的所有元素</td></tr><tr><td><code>boolean isEmpty</code></td><td>判断集合是否没有任何元素</td></tr><tr><td><code>boolean remove()</code></td><td>如果元素e出现在集合中，删除其中一个</td></tr><tr><td><code>int size()</code></td><td>返回集合中的元素个数</td></tr><tr><td><code>object[] toArray()</code></td><td>返回一个装有所有元素的数组</td></tr></tbody></table><h2 id="Collection实例"><a href="#Collection实例" class="headerlink" title="Collection实例"></a>Collection实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection; </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); System.out.println(list.size()); </span><br><span class="line">        System.out.println(list.isEmpty()); </span><br><span class="line">        list.add(<span class="string">&quot;我&quot;</span>); </span><br><span class="line">        list.add(<span class="string">&quot;爱&quot;</span>); </span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>); </span><br><span class="line">        System.out.println(list.size()); </span><br><span class="line">        System.out.println(list.isEmpty()); </span><br><span class="line">        Object[] array = list.toArray(); System.out.println(Arrays.toString(array)); </span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123; </span><br><span class="line">            System.out.println(s); </span><br><span class="line">        &#125;</span><br><span class="line">        list.remove(<span class="string">&quot;爱&quot;</span>); </span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123; </span><br><span class="line">            System.out.println(s); </span><br><span class="line">        &#125;</span><br><span class="line">        list.clear(); </span><br><span class="line">        System.out.println(list.size()); </span><br><span class="line">        System.out.println(list.isEmpty()); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201181620112.png" alt="image-20220118162033052"></p><h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><h2 id="Map常用方法说明"><a href="#Map常用方法说明" class="headerlink" title="Map常用方法说明"></a>Map常用方法说明</h2><table><thead><tr><th>方法签名</th><th>说明</th></tr></thead><tbody><tr><td><code>V get(oblect k)</code></td><td>根据指定的k查找对应的v</td></tr><tr><td><code>V getOrDefault(object k, v defaultValue)</code></td><td>根据制定的k查找对应的v，没哟找到用默认值代替</td></tr><tr><td><code>V put(k key,V value)</code></td><td>将指定的k-v放入Map</td></tr><tr><td><code>boolean containsKey(object key)</code></td><td>判断是否包含key</td></tr><tr><td><code>boolean containsValue(object value)</code></td><td>判断是否包含value</td></tr><tr><td><code>Set&lt;Map.Entry&lt;k,v&gt;&gt; entrtSet()</code></td><td>将所有键值对返回</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断是否为空</td></tr><tr><td><code>int size()</code></td><td>返回键值对的数量</td></tr></tbody></table><h2 id="Map接口实例"><a href="#Map接口实例" class="headerlink" title="Map接口实例"></a>Map接口实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        System.out.println(map.size()); System.out.println(map.isEmpty());</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;作者&quot;</span>)); </span><br><span class="line">        System.out.println(map.getOrDefault(<span class="string">&quot;作者&quot;</span>, <span class="string">&quot;佚名&quot;</span>)); System.out.println(map.containsKey(<span class="string">&quot;作者&quot;</span>)); System.out.println(map.containsValue(<span class="string">&quot;佚名&quot;</span>)); </span><br><span class="line">        map.put(<span class="string">&quot;作者&quot;</span>, <span class="string">&quot;鲁迅&quot;</span>); map.put(<span class="string">&quot;标题&quot;</span>, <span class="string">&quot;狂人日记&quot;</span>); </span><br><span class="line">        map.put(<span class="string">&quot;发表时间&quot;</span>, <span class="string">&quot;1918年&quot;</span>); </span><br><span class="line">        System.out.println(map.size()); </span><br><span class="line">        System.out.println(map.isEmpty()); </span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;作者&quot;</span>)); </span><br><span class="line">        System.out.println(map.getOrDefault(<span class="string">&quot;作者&quot;</span>, <span class="string">&quot;佚名&quot;</span>)); System.out.println(map.containsKey(<span class="string">&quot;作者&quot;</span>)); System.out.println(map.containsValue(<span class="string">&quot;佚名&quot;</span>)); </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey());                                               System.out.println(entry.getValue()); </span><br><span class="line">     &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201181629084.png" alt="image-20220118162935005"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode数组刷题1</title>
      <link href="/2022/01/08/LeetCode%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%981/"/>
      <url>/2022/01/08/LeetCode%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h1><p>题目：<br><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201072110783.png" alt="image-20220107211032282"></p><blockquote><p>题目分析：</p><p>给出一个数组和目标值，找到目标值所在的位置，返回所在位置的数组下标，如果数组中不存在目标值就返回-1</p></blockquote><p>看到题目的瞬间，就想我直接一个for循环，直接可以写完收工，可看看题目，不对劲，这道题叫做二分查找，所以需要用二分查找解决。</p><blockquote><p>回忆二分查找：</p><p>通过比较中间位置的值和目标值的大小关系，不断的缩小查找范围，知道最后不满足自己设定的条件</p></blockquote><p>代码部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码分析：</p><p>定义两个<code>int</code>类型的变量，表示数组的最左边和最右边，因为是二分查找，所以说left&gt;right表示在数组中没有找到目标值，所以不需要继续循环寻找目标值。</p><p>在循环里设置mid表示中间值，因为每次循环时都会对left和right进行改变，所以将mid初始化在循环内部。</p><p>判断：<code>nums[mid]</code>是我们寻找的值，如果我们找到的值小于目标值，又因为这个数组是升序的，mid左侧的所有元素都会小于目标值，不需要继续判断，这是将<code>left = mid + 1;</code>同理找到的值大于目标值，mid右侧的值全部大于目标值，无需查找。</p></blockquote><h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>题目：<br><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201072229212.png" alt="image-20220107222939085"></p><blockquote><p>题目分析：</p><p>在数组中找到目标值，如果没有找到，就返回目标值应该被插入的位置。</p><p>情况一：找到目标值，返回下标。</p><p>情况二：未找到目标值，最后返回循环结束后的left</p></blockquote><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202201072237651.png" alt="image-20220107223754591"></p><p>题目分析：</p><blockquote><p>寻找目标值的开始位置和目标值的结束位置，没有找到的话就返回[-1,-1].</p><p>情况分析：<br>情况一：要找的目标值在数组范围的左边或者右边，例如数组{3,5,7}，目标值为2或者9，就直接返回[-1,-1]</p><p>情况二：要找的值在数组范围内，但数组中并没有该目标值，例如数组{3,5,7}，目标值为4，就直接返回[-1,-1]</p><p>情况三：可以在数组中找到目标值</p></blockquote><blockquote><p>我们可以定义两个方法寻找边界，<code>getLeftBorder()</code>方法寻找左边界，<code>getRighterBorder()</code>方法用来寻找右边界</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftBorder = getLeftBorder (nums, target);</span><br><span class="line">        <span class="keyword">int</span> righterBorder = getRighterBorder (nums, target);</span><br><span class="line">        <span class="keyword">if</span>(leftBorder == -<span class="number">2</span> || righterBorder == -<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(righterBorder - leftBorder &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;leftBorder + <span class="number">1</span>, righterBorder - <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftBorder</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftBorder = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                leftBorder = right; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRighterBorder</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> righterBorder = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                righterBorder = left;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> righterBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>异常处理</title>
      <link href="/2021/12/07/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2021/12/07/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="异常的背景"><a href="#异常的背景" class="headerlink" title="异常的背景"></a>异常的背景</h1><h2 id="初识异常"><a href="#初识异常" class="headerlink" title="初识异常"></a>初识异常</h2><p><strong>除以0</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span> / <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><p><strong>数组下标越界</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: <span class="number">100</span></span><br></pre></td></tr></table></figure><p><strong>访问null对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(t.num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br></pre></td></tr></table></figure><p>所谓异常指的就是程序在 <strong>运行时</strong> 出现错误时通知调用者的一种机制</p><blockquote><p>关键字 “运行时”</p><p>有些错误是这样的, 例如将 <code>System.out.println</code> 拼写错了, 写成了 <code>system.out.println</code>. 此时编译过程中就会出错, 这是 “编译期” 出错.</p><p>而运行时指的是程序已经编译通过得到 class 文件了, 再由 JVM 执行过程中出现的错误</p></blockquote><p>异常的种类有很多, 不同种类的异常具有不同的含义, 也有不同的处理方式</p><p><strong>防御式编程</strong></p><p>错误在代码中是客观存在的. 因此我们要让程序出现问题的时候及时通知程序猿. 我们有两种主要的方式</p><p><strong>LBYL</strong>: Look Before You Leap. 在操作之前就做充分的检查.</p><p><strong>EAFP</strong>: It’s Easier to Ask Forgiveness than Permission. “事后获取原谅比事前获取许可更容易”. 也就是先操作, 遇到问题再处理.</p><p><strong>异常的核心思想就是 EAFP</strong></p><h2 id="异常的好处"><a href="#异常的好处" class="headerlink" title="异常的好处"></a>异常的好处</h2><p>例如, 我们用伪代码演示一下开始一局王者荣耀的过程.</p><p><strong>LBYL</strong> <strong>风格的代码</strong>(不使用异常)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> ret = <span class="keyword">false</span>;</span><br><span class="line">ret = 登陆游戏();</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line"> 处理登陆游戏错误;</span><br><span class="line">    <span class="keyword">return</span>; &#125;</span><br><span class="line">ret = 开始匹配();</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line"> 处理匹配错误;</span><br><span class="line">    <span class="keyword">return</span>; &#125;</span><br><span class="line">ret = 游戏确认();</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line"> 处理游戏确认错误;</span><br><span class="line">    <span class="keyword">return</span>; &#125;</span><br><span class="line">ret = 选择英雄();</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">    处理选择英雄错误;</span><br><span class="line">    <span class="keyword">return</span>; &#125;</span><br><span class="line">ret = 载入游戏画面();</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line"> 处理载入游戏错误;</span><br><span class="line">    <span class="keyword">return</span>; &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><strong>EAFP</strong> <strong>风格的代码</strong>(使用异常)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    登陆游戏();</span><br><span class="line">    开始匹配();</span><br><span class="line">    游戏确认();</span><br><span class="line">    选择英雄();</span><br><span class="line">    载入游戏画面();</span><br><span class="line">   ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (登陆游戏异常) &#123;</span><br><span class="line">    处理登陆游戏异常;</span><br><span class="line">&#125; <span class="keyword">catch</span> (开始匹配异常) &#123;</span><br><span class="line"> 处理开始匹配异常;</span><br><span class="line">&#125; <span class="keyword">catch</span> (游戏确认异常) &#123;</span><br><span class="line"> 处理游戏确认异常;</span><br><span class="line">&#125; <span class="keyword">catch</span> (选择英雄异常) &#123;</span><br><span class="line"> 处理选择英雄异常;</span><br><span class="line">&#125; <span class="keyword">catch</span> (载入游戏画面异常) &#123;</span><br><span class="line"> 处理载入游戏画面异常; </span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>对比两种不同风格的代码, 我们可以发现, 使用第一种方式, 正常流程和错误处理流程代码混在一起, 代码整体显的比较混乱. 而第二种方式正常流程和错误流程是分离开的, 更容易理解代码</p><h1 id="异常的基本用法"><a href="#异常的基本用法" class="headerlink" title="异常的基本用法"></a>异常的基本用法</h1><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a><strong>捕获异常</strong></h2><p><strong>基本语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line"> 有可能出现异常的语句 ; </span><br><span class="line">&#125;<span class="keyword">catch</span> (异常类型 异常对象) &#123;</span><br><span class="line">&#125; ...</span><br><span class="line">[<span class="keyword">finally</span> &#123;</span><br><span class="line"> 异常的出口</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><blockquote><p>try 代码块中放的是可能出现异常的代码.</p><p>catch 代码块中放的是出现异常后的处理行为.</p><p>finally 代码块中的代码用于处理善后工作, 会在最后执行.</p><p>其中 finally 都可以根据情况选择加或者不加.</p></blockquote><p><strong>代码示例1</strong> 不处理异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">before</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: <span class="number">100</span></span><br></pre></td></tr></table></figure><p>我们发现一旦出现异常, 程序就终止了. after 没有正确输出</p><p><strong>代码示例2</strong> 使用 try catch 后的程序执行过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">    <span class="comment">// 打印出现异常的调用栈</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;after try catch&quot;</span>);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">before</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: <span class="number">100</span></span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">10</span>)</span><br><span class="line">after <span class="keyword">try</span> <span class="keyword">catch</span></span><br></pre></td></tr></table></figure><p>我们发现, 一旦 try 中出现异常, 那么 try 代码块中的程序就不会继续执行, 而是交给 catch 中的代码来执行. catch 执行完毕会继续往下执行</p><blockquote><p><strong>关于异常的处理方式</strong></p><p>异常的种类有很多, 我们要根据不同的业务场景来决定.</p><p>对于比较严重的问题(例如和算钱相关的场景), 应该让程序直接崩溃, 防止造成更严重的后果</p><p>对于不太严重的问题(大多数场景), 可以记录错误日志, 并通过监控报警程序及时通知程序猿</p><p>对于可能会恢复的问题(和网络相关的场景), 可以尝试进行重试.</p><p>在我们当前的代码中采取的是经过简化的第二种方式. 我们记录的错误日志是出现异常的方法调用信息, 能很快速的让我们找到出现异常的位置. 以后在实际工作中我们会采取更完备的方式来记录异常信息</p></blockquote><blockquote><p><strong>关于</strong> <strong>“调用栈”</strong></p><p>方法之间是存在相互调用关系的, 这种调用关系我们可以用 “调用栈” 来描述. 在 JVM 中有一块内存空间称为 “虚拟机栈” 专门存储方法之间的调用关系. 当代码中出现异常的时候, 我们就可以使用     <code>e.printStackTrace();</code> 的方式查看出现异常代码的调用栈.</p></blockquote><p><strong>代码示例3</strong> catch 只能处理对应种类的异常</p><p>我们修改了代码, 让代码抛出的是空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;after try catch&quot;</span>);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">before</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>此时, catch 语句不能捕获到刚才的空指针异常. 因为异常类型不匹配</p><p><strong>代码示例4</strong> catch 可以有多个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是个数组下标越界异常&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是个空指针异常&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;after try catch&quot;</span>);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">before</span><br><span class="line">这是个空指针异常</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">12</span>)</span><br><span class="line">after <span class="keyword">try</span> <span class="keyword">catch</span></span><br></pre></td></tr></table></figure><p>一段代码可能会抛出多种不同的异常, 不同的异常有不同的处理方式. 因此可以搭配多个 catch 代码块.</p><p>如果多个异常的处理方式是完全相同, 也可以写成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (ArrayIndexOutOfBoundsException | NullPointerException e) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多个catch时，异常子类在上面，分类在下面</p></blockquote><p><strong>代码示例5</strong> 也可以用一个 catch 捕获所有异常(不推荐)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;after try catch&quot;</span>);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">before</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">12</span>)</span><br><span class="line">after <span class="keyword">try</span> <span class="keyword">catch</span></span><br></pre></td></tr></table></figure><p>由于 Exception 类是所有异常类的父类. 因此可以用这个类型表示捕捉所有异常.</p><blockquote><p>备注: catch 进行类型匹配的时候, 不光会匹配相同类型的异常对象, 也会捕捉目标异常类型的子类对象.</p><p>如刚才的代码, <code>NullPointerException</code> 和<code> ArrayIndexOutOfBoundsException</code> 都是 Exception 的子类, 因此都能被捕获到</p></blockquote><p><strong>代码示例6</strong> finally 表示最后的善后工作, 例如释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">    System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally code&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">before</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">12</span>)</span><br><span class="line"><span class="keyword">finally</span> code</span><br></pre></td></tr></table></figure><p>无论是否存在异常, finally 中的代码一定都会执行到. 保证最终一定会执行到 Scanner 的 close 方法</p><p><strong>代码示例7</strong> 使用 try 负责回收资源</p><p>刚才的代码可以有一种等价写法, 将 Scanner 对象在 try 的 ( ) 中创建, 就能保证在 try 执行完毕后自动调用 Scanner的 close 方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner sc = <span class="keyword">new</span> Scanner(System.in)) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">    System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码示例8</strong> 如果本方法中没有合适的处理异常的方式, 就会沿着调用栈向上传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        func();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;after try catch&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接结果</span></span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: <span class="number">100</span></span><br><span class="line"> at demo02.Test.func(Test.java:<span class="number">18</span>)</span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">9</span>)</span><br><span class="line">after <span class="keyword">try</span> <span class="keyword">catch</span></span><br></pre></td></tr></table></figure><p><strong>代码示例9</strong> 如果向上一直传递都没有合适的方法处理异常, 最终就会交给 JVM 处理, 程序就会异常终止(和我们最开始未使用 try catch 时是一样的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    func();</span><br><span class="line">        System.out.println(<span class="string">&quot;after try catch&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: <span class="number">100</span></span><br><span class="line"> at demo02.Test.func(Test.java:<span class="number">14</span>)</span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>可以看到, 程序已经异常终止了, 没有执行到 <code>System.out.println(&quot;after try catch&quot;);</code> 这一行</p><p><strong>异常处理流程</strong></p><blockquote><p>程序先执行 try 中的代码</p><p>如果 try 中的代码出现异常, 就会结束 try 中的代码, 看和 catch 中的异常类型是否匹配.</p><p>如果找到匹配的异常类型, 就会执行 catch 中的代码</p><p>如果没有找到匹配的异常类型, 就会将异常向上传递到上层调用者.</p><p>无论是否找到匹配的异常类型, finally 中的代码都会被执行到(在该方法结束之前执行).</p><p>如果上层调用者也没有处理的了异常, 就继续向上传递.</p><p>一直到 main 方法也没有合适的代码处理异常, 就会交给 JVM 来进行处理, 此时程序就会异常终止.</p></blockquote><p><strong>抛出异常</strong></p><p>除了 Java 内置的类会抛出一些异常之外, 程序猿也可以手动抛出某个异常. 使用 throw 关键字完成这个操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> System.out.println(divide(<span class="number">10</span>, <span class="number">0</span>)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;抛出除 0 异常&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> x / y; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: 抛出除 <span class="number">0</span> 异常</span><br><span class="line"> at demo02.Test.divide(Test.java:<span class="number">14</span>) </span><br><span class="line"> at demo02.Test.main(Test.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>在这个代码中, 我们可以根据实际情况来抛出需要的异常. 在构造异常对象同时可以指定一些描述性信息</p><p><strong>异常说明</strong></p><p>我们在处理异常的时候, 通常希望知道这段代码中究竟会出现哪些可能的异常.</p><p>我们可以使用 throws 关键字, 把可能抛出的异常显式的标注在方法定义的位置. 从而提醒调用者要注意捕获这些异常.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> ArithmeticException </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;抛出除 0 异常&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> x / y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于</strong> <strong>finally</strong> <strong>的注意事项</strong></p><p>finally 中的代码保证一定会执行到. 这也会带来一些麻烦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> System.out.println(func()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">10</span>; </span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">20</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><p>finally 执行的时机是在方法返回之前(try 或者 catch 中如果有 return 会在这个 return 之前执行 finally). 但是如果finally 中也存在 return 语句, 那么就会执行 finally 中的 return, 从而不会执行到 try 中原有的 return.</p><p>一般我们不建议在 finally 中写 return (被编译器当做一个警告).</p><h1 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h1><p>Java 内置了丰富的异常体系, 用来表示不同情况下的异常.</p><p>下图表示 Java 内置的异常类之间的继承关系:</p><blockquote><p>顶层类 Throwable 派生出两个重要的子类, Error 和 Exception</p><p>其中 Error 指的是 Java 运行时内部错误和资源耗尽错误. <strong>应用程序不抛出此类异常</strong>. 这种内部错误一旦出现，</p><p>除了告知用户并使程序终止之外, 再无能无力. 这种情况很少出现.</p><p>Exception 是我们程序猿所使用的异常类的父类.</p><p>其中 Exception 有一个子类称为 <code>RuntimeException</code> , 这里面又派生出很多我们常见的异常类</p><p><code>NullPointerException </code>, <code>IndexOutOfBoundsException</code> 等</p></blockquote><p>Java语言规范将派生于 Error 类或 <code>RuntimeException </code>类的所有异常称为 <strong>非受查异常</strong>, 所有的其他异常称为 <strong>受查异常</strong>.</p><p>如果一段代码可能抛出 <strong>受查异常</strong>, 那么必须显式进行处理.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> System.out.println(readFile()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 尝试打开文件, 并读其中的一行. </span></span><br><span class="line"> File file = <span class="keyword">new</span> File(<span class="string">&quot;d:/test.txt&quot;</span>); </span><br><span class="line"> <span class="comment">// 使用文件对象构造 Scanner 对象. </span></span><br><span class="line"> Scanner sc = <span class="keyword">new</span> Scanner(file); </span><br><span class="line"> <span class="keyword">return</span> sc.nextLine(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">13</span>, <span class="number">22</span>) java: 未报告的异常错误java.io.FileNotFoundException; 必须对其进行捕获或声明以便抛出</span><br></pre></td></tr></table></figure><p>查看 Scanner 的构造方法可以发现, 存在<code> FileNotFoundException</code> 这样的异常说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(File source)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如 <code>FileNotFoundException</code> 这样的异常就是受查异常. 如果不显式处理, 编译无法通过.</p><p>显式处理的方式有两种:</p><p><strong>a)</strong> <strong>使用</strong> <strong>try catch</strong> <strong>包裹起来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> System.out.println(readFile()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> File file = <span class="keyword">new</span> File(<span class="string">&quot;d:/test.txt&quot;</span>); </span><br><span class="line"> Scanner sc = <span class="keyword">null</span>; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> sc = <span class="keyword">new</span> Scanner(file); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123; </span><br><span class="line"> e.printStackTrace(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> sc.nextLine(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>b)</strong> <strong>在方法上加上异常说明</strong>, <strong>相当于将处理动作交给上级调用者</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line"> try &#123; </span><br><span class="line"> System.out.println(readFile()); </span><br><span class="line"> &#125; catch (FileNotFoundException e) &#123; </span><br><span class="line"> e.printStackTrace(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">public static String readFile() throws FileNotFoundException &#123; </span><br><span class="line"> File file = new File(&quot;d:/test.txt&quot;); </span><br><span class="line"> Scanner sc = new Scanner(file); </span><br><span class="line"> return sc.nextLine(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>别忘了 IDEA 神奇的 alt + enter, 能够快速修正代码</p></blockquote><h1 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h1><p> Java 中虽然已经内置了丰富的异常类, 但是我们实际场景中可能还有一些情况需要我们对异常类进行扩展, 创建符合我</p><p>们实际情况的异常.</p><p>例如, 我们实现一个用户登陆功能.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> String userName = <span class="string">&quot;admin&quot;</span>; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">&quot;123456&quot;</span>; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String userName, String password)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (!Test.userName.equals(userName)) &#123; </span><br><span class="line"> <span class="comment">// TODO 处理用户名错误</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (!Test.password.equals(password)) &#123; </span><br><span class="line"> <span class="comment">// TODO 处理密码错误</span></span><br><span class="line"> &#125; </span><br><span class="line"> System.out.println(<span class="string">&quot;登陆成功&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们在处理用户名密码错误的时候可能就需要抛出两种异常. 我们可以基于已有的异常类进行扩展(继承), 创建和我们业务相关的异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserError</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">UserError</span><span class="params">(String message)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(message); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PasswordError</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PasswordError</span><span class="params">(String message)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(message); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们的 login 代码可以改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> login(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (UserError userError) &#123; </span><br><span class="line"> userError.printStackTrace(); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (PasswordError passwordError) &#123; </span><br><span class="line"> passwordError.printStackTrace(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String userName, String password)</span> <span class="keyword">throws</span> UserError, </span></span><br><span class="line"><span class="function">PasswordError </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (!Test.userName.equals(userName)) &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> UserError(<span class="string">&quot;用户名错误&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (!Test.password.equals(password)) &#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> PasswordError(<span class="string">&quot;密码错误&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> System.out.println(<span class="string">&quot;登陆成功&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><blockquote><p>自定义异常通常会继承自 Exception 或者 <code>RuntimeException</code></p><p>继承自 Exception 的异常默认是受查异常</p><p>继承自 <code>RuntimeException</code> 的异常默认是非受查异常</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>String类的认识</title>
      <link href="/2021/12/04/String%E7%B1%BB%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
      <url>/2021/12/04/String%E7%B1%BB%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="创建String类"><a href="#创建String类" class="headerlink" title="创建String类"></a>创建String类</h1><p>常见的构造String的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line">String str=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">String str =<span class="keyword">new</span> String (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line"><span class="keyword">char</span>[] ch=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>.<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">String str=<span class="keyword">new</span> String (ch);</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><blockquote><p>“hello” 这样的字符串字面值常量, 类型也是 String.</p><p>String 也是<strong>引用类型</strong>. String str = “Hello”; 这样的代码内存布局如下</p></blockquote><p><img src="C:/Users/78581/AppData/Roaming/Typora/typora-user-images/image-20211121172912508.png" alt="image-20211121172912508"></p><p>由于 String 是引用类型, 因此对于以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2 = str1;</span><br></pre></td></tr></table></figure><p>内存布局如图</p><p><img src="C:/Users/78581/AppData/Roaming/Typora/typora-user-images/image-20211122121452707.png" alt="image-20211122121452707"></p><p>那么有同学可能会说, 是不是修改 str1 , str2 也会随之变化呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><p>我们发现, “修改” str1 之后, str2 也没发生变化, 还是 hello?</p><p>事实上, str1 = “world” 这样的代码并不算 “修改” 字符串, 而是让 str1 这个引用指向了一个新的 String 对象.</p><h1 id="字符串比较相等"><a href="#字符串比较相等" class="headerlink" title="字符串比较相等"></a>字符串比较相等</h1><p>如果现在有两个int型变量，判断其相等可以使用 == 完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">10</span> ;</span><br><span class="line">System.out.println(x == y); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>如果说现在在String类对象上使用 == ？</p><p><strong>代码1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span> </span><br></pre></td></tr></table></figure><p>看起来貌似没啥问题, 再换个代码试试, 发现情况不太妙.</p><p><strong>代码2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>我们来分析两种创建 String 方式的差异.</p><p><strong>代码1内存布局</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211122121452707.png" alt="image-20211122121452707"></p><p>我们发现, str1 和 str2 是指向同一个对象的. 此时如 “Hello” 这样的字符串常量是在 <strong>字符串常量池</strong> 中.</p><blockquote><p>关于字符串常量池</p><p>如 “Hello” 这样的字符串字面值常量, 也是需要一定的内存空间来存储的. 这样的常量具有一个特点, 就是不需要</p><p>修改(常量嘛). 所以如果代码中有多个地方引用都需要使用 “Hello” 的话, 就直接引用到常量池的这个位置就行</p><p>了, 而没必要把 “Hello” 在内存中存储两次.</p></blockquote><p><strong>代码2内存布局</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211122122049827.png" alt="image-20211122122049827"></p><p>通过 String str1 = new String(“Hello”); 这样的方式创建的 String 对象相当于再堆上另外开辟了空间来存储</p><p>“Hello” 的内容, 也就是内存中存在两份 “Hello”.</p><p><strong>String</strong> <strong>使用</strong> <strong>==</strong> <strong>比较并不是在比较字符串内容</strong><strong>,</strong> <strong>而是比较两个引用是否是指向同一个对象</strong>.</p><p><strong>关于对象的比较</strong></p><blockquote><p>面向对象编程语言中, 涉及到对象的比较, 有三种不同的方式, 比较身份, 比较值, 比较类型.</p><p>在大部分编程语言中 == 是用来比较比较值的. 但是 Java 中的 == 是用来比较身份的.</p><p>如何理解比较值和比较身份呢?</p><p>可以想象一个场景, 现在取快递, 都有包裹储物柜. 上面有很多的格子. 每个格子里面都放着东西.</p><p>例如, “第二行, 左数第五列” 这个柜子和 “第二行, 右数第二列” 这个柜子是同一个柜子, 就是 <strong>身份相同</strong>. 如果身份</p><p>相同, 那么里面放的东西一定也相同 (值一定也相同).</p><p>例如, “第一行, 左数第一列” 这个柜子和 “第一行, 左数第二列” 这两个柜子不是同一个柜子, 但是柜子打开后发现</p><p>里面放着的是完全一模一样的两双鞋子. 这个时候就是 <strong>值相同</strong></p></blockquote><p>Java 中要想比较字符串的内容, 必须采用String类提供的equals方法.</p><p><strong>equals</strong> <strong>使用注意事项</strong></p><p>现在需要比较 str 和 “Hello” 两个字符串是否相等, 我们该如何来写呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(str2.equals(str1)); // 或者这样写也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>equals 使用注意事项</strong></p><p>现在需要比较 str 和 “Hello” 两个字符串是否相等, 我们该如何来写呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">System.out.println(str.equals(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>.equals(str));</span><br></pre></td></tr></table></figure><p>在上面的代码中, 哪种方式更好呢?</p><p>我们更推荐使用 “方式二”. 一旦 str 是 null, 方式一的代码会抛出异常, 而方式二不会</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">System.out.println(str.equals(<span class="string">&quot;Hello&quot;</span>));  <span class="comment">// 执行结果 抛出 java.lang.NullPointerException 异 常</span></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>.equals(str));<span class="comment">//执行结果 false</span></span><br></pre></td></tr></table></figure><p><strong>注意事项:</strong> “Hello” 这样的字面值常量, 本质上也是一个 String 对象, 完全可以使用 equals 等 String 对象的方法</p><blockquote><p>因为引用类型变量存储的是地址，所以“=”比较的是两个引用变量的地址是否相同，而不是比较内容</p><p>String重写的equals方法比较的就是变量中的每一个具体值</p></blockquote><h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a><strong>字符串常量池</strong></h1><p>在上面的例子中, String类的两种实例化操作, 直接赋值和 new 一个新的 String</p><p><strong>a)</strong> <strong>直接赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line">String str2 = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line">String str3 = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line">System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str3); <span class="comment">// true</span></span><br><span class="line">System.out.println(str2 == str3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为什么现在并没有开辟新的堆内存空间呢？</p><p>String类的设计使用了<strong>共享设计模式</strong></p><p><strong>在JVM底层实际上会自动维护一个对象池（字符串常量池)</strong></p><ol><li>如果现在采用了直接赋值的模式进行String类的对象实例化操作，那么该实例化对象（字符串内容）将自动保存</li></ol><p>到这个对象池之中.</p><ol start="2"><li><p>如果下次继续使用直接赋值的模式声明String类对象，此时对象池之中如若有指定内容，将直接进行引用</p></li><li><p>如若没有，则开辟新的字符串对象而后将其保存在对象池之中以供下次使用</p></li></ol><blockquote><p><strong>理解</strong> <strong>“<strong><strong>池</strong></strong>“ (pool)</strong></p><p>“池” 是编程中的一种常见的, 重要的提升效率的方式, 我们会在未来的学习中遇到各种 “内存池”, “线程池”, “数据</p><p>库连接池” ….</p><p>然而池这样的概念不是计算机独有, 也是来自于生活中.</p></blockquote><p><strong>b)</strong> <strong>采用构造方法</strong></p><p>类对象使用构造方法实例化是标准做法。分析如下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211122123306272.png" alt="image-20211122123306272"></p><p>这样的做法有两个缺点:</p><ol><li>如果使用String构造方法就会开辟两块堆内存空间，并且其中一块堆内存将成为垃圾空间(字符串常量 “hello” 也</li></ol><p>是一个匿名对象, 用了一次之后就不再使用了, 就成为垃圾空间, 会被 JVM 自动回收掉).</p><ol start="2"><li>字符串共享问题. 同一个字符串可能会被存储多次, 比较浪费空间</li></ol><p>我们可以使用 String 的 intern 方法来手动把 String 对象加入到字符串常量池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该字符串常量并没有保存在对象池之中</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) ; </span><br><span class="line">String str2 = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line">System.out.println(str1 == str2); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">    </span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>).intern() ; </span><br><span class="line">String str2 = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line">System.out.println(str1 == str2); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>面试题：请解释String类中两种对象实例化的区别</strong></p><ol><li><p>直接赋值：只会开辟一块堆内存空间，并且该字符串对象可以自动保存在对象池中以供下次使用。</p></li><li><p>构造方法：会开辟两块堆内存空间，不会自动保存在对象池中，可以使用intern()方法手工入池。</p></li></ol></blockquote><p>综上, 我们一般采取直接赋值的方式创建 String 对象</p><h1 id="理解字符串的不可变"><a href="#理解字符串的不可变" class="headerlink" title="理解字符串的不可变"></a>理解字符串的不可变</h1><p>字符串是一种不可变对象. 它的内容不可改变.</p><p>String 类的内部实现也是基于 char[] 来实现的, 但是 String 类并没有提供 set 方法之类的来修改内部的字符数组.</p><p>感受下形如这样的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line">str = str + <span class="string">&quot; world&quot;</span> ; </span><br><span class="line">str += <span class="string">&quot;!!!&quot;</span> ; </span><br><span class="line">System.out.println(str); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">hello world!!!</span><br></pre></td></tr></table></figure><p>形如 += 这样的操作, 表面上好像是修改了字符串, 其实不是. 内存变化如下:</p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211122124550762.png" alt="image-20211122124550762"></p><h1 id="字符、字节与字符串"><a href="#字符、字节与字符串" class="headerlink" title="字符、字节与字符串"></a>字符、字节与字符串</h1><h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public String(char[] ch)</td><td align="center">构造</td><td align="center">将字符数组中所有的内容变成字符串</td></tr><tr><td align="center">2</td><td align="center">public String(char[] ,int offest,int count)</td><td align="center">构造</td><td align="center">将部分字符数组中的内容变成字符串</td></tr><tr><td align="center">3</td><td align="center">public char charAt(int index)</td><td align="center">普通</td><td align="center">取得指定索引位置的字符，索引从0开始</td></tr><tr><td align="center">4</td><td align="center">public char[] toCharArray()</td><td align="center">普通</td><td align="center">将字符串变为字符数组返回</td></tr></tbody></table><p><strong>代码示例</strong>: 获取指定位置的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span> ;  </span><br><span class="line">System.out.println(str.charAt(<span class="number">0</span>));  <span class="comment">// 下标从 0 开始// 执行结果</span></span><br><span class="line">h </span><br><span class="line">System.out.println(str.charAt(<span class="number">10</span>)); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">产生 StringIndexOutOfBoundsException 异常</span><br></pre></td></tr></table></figure><p>代码示例: 字符串与字符数组的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;helloworld&quot;</span> ; </span><br><span class="line"><span class="comment">// 将字符串变为字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] data = str.toCharArray() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123; </span><br><span class="line"> System.out.print(data[i]+<span class="string">&quot; &quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 字符数组转为字符串</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data)); <span class="comment">// 全部转换</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data,<span class="number">5</span>,<span class="number">5</span>)); <span class="comment">// 部分转换</span></span><br></pre></td></tr></table></figure><p><strong>代码示例</strong><strong>:</strong> 给定字符串一个字符串, 判断其是否全部由数字所组成.</p><p>思路: 将字符串变为字符数组而后判断每一位字符是否是” 0 “~”‘9’”之间的内容，如果是则为数字.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     String str = <span class="string">&quot;1a23456&quot;</span> ; </span><br><span class="line">     System.out.println(isNumber(str)? <span class="string">&quot;字符串由数字所组成！&quot;</span> : <span class="string">&quot;字符串中有非数字成员！&quot;</span>);</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String str)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">char</span>[] data = str.toCharArray() ; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (data[i]&lt;<span class="string">&#x27;0&#x27;</span> || data[i]&gt;<span class="string">&#x27;9&#x27;</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span> ; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">true</span> ; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="字节和字符串"><a href="#字节和字符串" class="headerlink" title="字节和字符串"></a>字节和字符串</h2><p>字节常用于数据传输以及编码转换的处理之中，String 也能方便的和 byte[] 相互转换</p><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public String(byte bytes[])</td><td align="center">构造</td><td align="center">将字符数组变为字符串</td></tr><tr><td align="center">2</td><td align="center">public String(bute bytes[],int offset,int length)</td><td align="center">构造</td><td align="center">将部分字节数组中的内容变为字符串</td></tr><tr><td align="center">3</td><td align="center">public byte[] getBytes()</td><td align="center">普通</td><td align="center">将字符串一字符数组的形式返回</td></tr><tr><td align="center">4</td><td align="center">public byte[] getBytes(String charsetName)throwsUnsupportedEncodingException</td><td align="center">普通</td><td align="center">编译转换处理</td></tr></tbody></table><p><strong>代码示例</strong>:实现字符串与字节数组的转换处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;helloworld&quot;</span> ; </span><br><span class="line"><span class="comment">// String 转 byte[] </span></span><br><span class="line"><span class="keyword">byte</span>[] data = str.getBytes() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123; </span><br><span class="line"> System.out.print(data[i]+<span class="string">&quot; &quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// byte[] 转 String </span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br></pre></td></tr></table></figure><p>那么何时使用 byte[], 何时使用 char[] 呢?</p><ol><li>byte[] 是把 String 按照一个字节一个字节的方式处理, 这种适合在网络传输, 数据存储这样的场景下使用. 更适合</li></ol><p>针对二进制数据来操作.</p><ol start="2"><li>char[] 是吧 String 按照一个字符一个字符的方式处理, 更适合针对文本数据来操作, 尤其是包含中文的时候.</li></ol><blockquote><p>回忆概念: 文本数据 vs 二进制数据</p><p>一个简单粗暴的区分方式就是用记事本打开能不能看懂里面的内容.</p><p>如果看的懂, 就是文本数据(例如 .java 文件), 如果看不懂, 就是二进制数据(例如.class文件)</p></blockquote><h1 id="字符串常见操作"><a href="#字符串常见操作" class="headerlink" title="字符串常见操作"></a>字符串常见操作</h1><p>上面使用过String类提供的equals()方法，该方法本身是可以进行区分大小写的相等判断。除了这个方法之外，String</p><p>类还提供有如下的比较操作：</p><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public boolean equals(Object anObject)</td><td align="center">普通</td><td align="center">区分大小写的比较</td></tr><tr><td align="center">2</td><td align="center">public boolean equalsIanore(Object anObject)</td><td align="center">普通</td><td align="center">不区分大小写的比较</td></tr><tr><td align="center">3</td><td align="center">public int conpareTo(String anotherString)</td><td align="center">普通</td><td align="center">比较两个字符串大小关系</td></tr></tbody></table><p><strong>代码示例</strong><strong>:</strong> 不区分大小写比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span> ; </span><br><span class="line">String str2 = <span class="string">&quot;Hello&quot;</span> ; </span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">// false </span></span><br><span class="line">System.out.println(str1.equalsIgnoreCase(str2)); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在String类中compareTo()方法是一个非常重要的方法，该方法返回一个整型，该数据会根据大小关系返回三类内</p><p>容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 相等：返回<span class="number">0.</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 小于：返回内容小于<span class="number">0.</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 大于：返回内容大于<span class="number">0</span>。</span><br></pre></td></tr></table></figure><p><strong>范例：观察compareTo()比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>.compareTo(<span class="string">&quot;a&quot;</span>)); <span class="comment">// -32 </span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.compareTo(<span class="string">&quot;A&quot;</span>)); <span class="comment">// 32 </span></span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>.compareTo(<span class="string">&quot;A&quot;</span>)); <span class="comment">// 0 </span></span><br><span class="line">System.out.println(<span class="string">&quot;AB&quot;</span>.compareTo(<span class="string">&quot;AC&quot;</span>)); <span class="comment">// -1 </span></span><br><span class="line">System.out.println(<span class="string">&quot;刘&quot;</span>.compareTo(<span class="string">&quot;杨&quot;</span>));</span><br></pre></td></tr></table></figure><p>compareTo()是一个可以区分大小关系的方法，是String方法里是一个非常重要的方法。</p><blockquote><p>字符串的比较大小规则, 总结成三个字 “字典序” 相当于判定两个字符串在一本词典的前面还是后面. 先比较第一</p><p>个字符的大小(根据 unicode 的值来判定), 如果不分胜负, 就依次比较后面的内容</p></blockquote><h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><p>从一个完整的字符串之中可以判断指定内容是否存在，对于查找方法有如下定义:</p><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public boolean contains(CharSequence s)</td><td align="center">普通</td><td align="center">判断一个子字符串是否存在</td></tr><tr><td align="center">2</td><td align="center">public int indexOf(String str)</td><td align="center">普通</td><td align="center">从头开始查找指定字符串的位置，查到了就返回位置的开始索引，如果查不到就返回-1</td></tr><tr><td align="center">3</td><td align="center">public int indexOf(String str,int fromIndex)</td><td align="center">普通</td><td align="center">从指定位置开始查找子字符串的位置</td></tr><tr><td align="center">4</td><td align="center">public int LastindexOf(String str)</td><td align="center">普通</td><td align="center">由后向前查找子字符串的位置</td></tr><tr><td align="center">5</td><td align="center">public int LastindexOf(String str,int fromIndex)</td><td align="center">普通</td><td align="center">从指定位置由后向前查找</td></tr><tr><td align="center">6</td><td align="center">public boolean startsWith(String prefix)</td><td align="center">普通</td><td align="center">判断是否以指定字符串开头</td></tr><tr><td align="center">7</td><td align="center">public boolean startsWith(String prefix,int toffset)</td><td align="center">普通</td><td align="center">从指定位置开始判断是否以指定字符串开头</td></tr><tr><td align="center">8</td><td align="center">public boolean endsWith(String suffit)</td><td align="center">普通</td><td align="center">判断是否以指定字符串结尾</td></tr></tbody></table><p><strong>代码示例</strong><strong>:</strong> 字符串查找，最好用最方便的就是contains()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;helloworld&quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.contains(<span class="string">&quot;world&quot;</span>)); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>该判断形式是从JDK1.5之后开始追加的，在JDK1.5以前要想实现与之类似的功能，就必须借助、indexOf()方法完</p><p>成。</p><p><strong>代码示例:</strong> 使用indexOf()方法进行位置查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;helloworld&quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.indexOf(<span class="string">&quot;world&quot;</span>)); <span class="comment">// 5,w开始的索引</span></span><br><span class="line"></span><br><span class="line">System.out.println(str.indexOf(<span class="string">&quot;bit&quot;</span>)); <span class="comment">// -1，没有查到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str.indexOf(<span class="string">&quot;hello&quot;</span>) != -<span class="number">1</span>) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">&quot;可以查到指定字符串！&quot;</span>); </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>现在基本都是用contains()方法完成。</p><p>使用indexOf()需要注意的是，如果内容重复，它只能返回查找的第一个位置</p><p><strong>代码示例:</strong> 使用indexOf()的注意点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;helloworld&quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.indexOf(<span class="string">&quot;l&quot;</span>)); <span class="comment">// 2 </span></span><br><span class="line"></span><br><span class="line">System.out.println(str.indexOf(<span class="string">&quot;l&quot;</span>,<span class="number">5</span>)); <span class="comment">// 8 </span></span><br><span class="line"></span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">&quot;l&quot;</span>)); <span class="comment">// 8 </span></span><br></pre></td></tr></table></figure><p>在进行查找的时候往往会判断开头或结尾。</p><p><strong>代码示例:</strong> 判断开头或结尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;**@@helloworld!!&quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.startsWith(<span class="string">&quot;**&quot;</span>)); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line">System.out.println(str.startsWith(<span class="string">&quot;@@&quot;</span>,<span class="number">2</span>)); <span class="comment">// ture </span></span><br><span class="line"></span><br><span class="line">System.out.println(str.endsWith(<span class="string">&quot;!!&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>使用一个指定的新的字符串替换掉已有的字符串数据，可用的方法如下</p><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public String replaceAll(String regex,Stringreplacement)</td><td align="center">普通</td><td align="center">替换所有的指定位置</td></tr><tr><td align="center">2</td><td align="center">public String replaceFirst(String regex,Stringreplacement)</td><td align="center">普通</td><td align="center">替换首个位置</td></tr></tbody></table><p><strong>代码示例:</strong> 字符串的替换处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;helloworld&quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.replaceAll(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;_&quot;</span>)); </span><br><span class="line"></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;_&quot;</span>)); </span><br></pre></td></tr></table></figure><p><strong>注意事项:</strong> 由于字符串是不可变对象, 替换不修改当前字符串, 而是产生一个新的字符串.</p><h2 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h2><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public String[] split(String regex)</td><td align="center">普通</td><td align="center">将字符串全部拆分</td></tr><tr><td align="center">2</td><td align="center">public String[] split(String regex，int limit)</td><td align="center">普通</td><td align="center">将字符串部分拆分，该数组长度是limit的极限</td></tr></tbody></table><p><strong>代码示例:</strong> 实现字符串的拆分处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello world hello bit&quot;</span> ; </span><br><span class="line"></span><br><span class="line">String[] result = str.split(<span class="string">&quot; &quot;</span>) ; <span class="comment">// 按照空格拆分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s: result) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.println(s); </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>代码示例:</strong> 字符串的部分拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello world hello bit&quot;</span> ; </span><br><span class="line"></span><br><span class="line">String[] result = str.split(<span class="string">&quot; &quot;</span>,<span class="number">2</span>) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s: result) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.println(s); </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>拆分是特别常用的操作. 一定要重点掌握. 另外有些特殊字符作为分割符可能无法正确切分, 需要加上转义.</p><p><strong>代码示例:</strong> 拆分IP地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;192.168.1.1&quot;</span> ; </span><br><span class="line"></span><br><span class="line">String[] result = str.split(<span class="string">&quot;\\.&quot;</span>) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String s: result) &#123; </span><br><span class="line"></span><br><span class="line"> System.out.println(s); </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><ol><li><p>字符”|”,”*”,”+”都得加上转义字符，前面加上”&quot;.</p></li><li><p>而如果是””，那么就得写成”\“.</p></li><li><p>如果一个字符串中有多个分隔符，可以用”|”作为连字符.</p></li></ol><p><strong>代码示例:</strong> 多次拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;name=zhangsan&amp;age=18&quot;</span> ; </span><br><span class="line">String[] result = str.split(<span class="string">&quot;&amp;&quot;</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123; </span><br><span class="line"> String[] temp = result[i].split(<span class="string">&quot;=&quot;</span>) ; </span><br><span class="line"> System.out.println(temp[<span class="number">0</span>]+<span class="string">&quot; = &quot;</span>+temp[<span class="number">1</span>]); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这种代码在以后的开发之中会经常出现</p><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>从一个完整的字符串之中截取出部分内容。可用方法如下：</p><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public String substring(int biginIndex)</td><td align="center">普通</td><td align="center">从指定索引截取到结尾</td></tr><tr><td align="center">2</td><td align="center">public String substring(int biginIndex,int endIndex)</td><td align="center">普通</td><td align="center">截取部分内容</td></tr></tbody></table><p><strong>代码示例</strong><strong>:</strong> 观察字符串截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;helloworld&quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.substring(<span class="number">5</span>)); </span><br><span class="line"></span><br><span class="line">System.out.println(str.substring(<span class="number">0</span>, <span class="number">5</span>)); </span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><strong>:</strong></p><ol><li><p>索引从0开始</p></li><li><p>注意前闭后开区间的写法, substring(0, 5) 表示包含 0 号下标的字符, 不包含 5 号下标</p></li></ol><h2 id="其他操作方法"><a href="#其他操作方法" class="headerlink" title="其他操作方法"></a>其他操作方法</h2><table><thead><tr><th align="center">No</th><th align="center">方法名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">public String trim( )</td><td align="center">普通</td><td align="center">去除字符串中的左右空格，保留中间的空格</td></tr><tr><td align="center">2</td><td align="center">public String toUpperCase( )</td><td align="center">普通</td><td align="center">字符串大写</td></tr><tr><td align="center">3</td><td align="center">public String toLowerCase( )</td><td align="center">普通</td><td align="center">字符串小写</td></tr><tr><td align="center">4</td><td align="center">public native String intern( )</td><td align="center">普通</td><td align="center">字符串入池操作</td></tr><tr><td align="center">5</td><td align="center">public String concat(String str )</td><td align="center">普通</td><td align="center">字符串连接，等同于“ + ”，不入池</td></tr><tr><td align="center">6</td><td align="center">public int length( )</td><td align="center">普通</td><td align="center">取得字符串长度</td></tr><tr><td align="center">7</td><td align="center">public boolean isEmpty( )</td><td align="center">普通</td><td align="center">判断是否为空字符串，但不是null，而是长度0</td></tr></tbody></table><p><strong>代码示例:</strong> 观察trim()方法的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot; hello world &quot; ; </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;[&quot;+str+&quot;]&quot;); </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;[&quot;+str.trim()+&quot;]&quot;); </span><br></pre></td></tr></table></figure><p>trim 会去掉字符串开头和结尾的空白字符(空格, 换行, 制表符等).</p><p><strong>代码示例:</strong> 大小写转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot; hello%$$%@#$%world 哈哈哈 &quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.toUpperCase()); </span><br><span class="line"></span><br><span class="line">System.out.println(str.toLowerCase()); </span><br></pre></td></tr></table></figure><p>这两个函数只转换字母。</p><p><strong>代码示例</strong><strong>:</strong> 字符串length()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot; hello%$$%@#$%world 哈哈哈 &quot;</span> ; </span><br><span class="line"></span><br><span class="line">System.out.println(str.length()); </span><br></pre></td></tr></table></figure><p>注意：数组长度使用数组名称.length属性，而String中使用的是length()方法</p><p><strong>代码示例:</strong> 观察isEmpty()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>.isEmpty()); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>.isEmpty()); </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> String().isEmpty());</span><br></pre></td></tr></table></figure><p>String类并没有提供首字母大写操作，需要自己实现.</p><p><strong>代码示例:</strong> 首字母大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> System.out.println(fistUpper(<span class="string">&quot;yuisama&quot;</span>)); </span><br><span class="line"> System.out.println(fistUpper(<span class="string">&quot;&quot;</span>)); </span><br><span class="line"> System.out.println(fistUpper(<span class="string">&quot;a&quot;</span>)); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fistUpper</span><span class="params">(String str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(str)||str==<span class="keyword">null</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> str ; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (str.length()&gt;<span class="number">1</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> str.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase()+str.substring(<span class="number">1</span>) ; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> str.toUpperCase() ; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h1><p>首先来回顾下String类的特点：</p><p>任何的字符串常量都是String对象，而且String的常量一旦声明不可改变，如果改变对象内容，改变的是其引用的指</p><p>向而已。</p><p>通常来讲String的操作比较简单，但是由于String的不可更改特性，为了方便字符串的修改，提供StringBuffffer和</p><p>StringBuilder类。</p><p>StringBuffffer 和 StringBuilder 大部分功能是相同的，我们课件上主要介绍 StringBuffffer</p><p>在String中使用”+”来进行字符串连接，但是这个操作在StringBuffffer类中需要更改为append()方法：</p><p>public synchronized StringBuffer append(各种数据类型 b) </p><p><strong>范例：观察StringBuffffer使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(); </span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>); </span><br><span class="line"> fun(sb); </span><br><span class="line">System.out.println(sb); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(StringBuffer temp)</span> </span>&#123; </span><br><span class="line"> temp.append(<span class="string">&quot;\n&quot;</span>).append(<span class="string">&quot;hhh&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>String和StringBuffffer最大的区别在于：String的内容无法修改，而StringBuffffer的内容可以修改。频繁修改字符串的</p><p>情况考虑使用StingBuffffer。</p><p>为了更好理解String和StringBuffffer，我们来看这两个类的继承结构:</p><table><thead><tr><th align="center">String类</th><th align="center">StringBuffer类</th></tr></thead><tbody><tr><td align="center">public fifinal class String implements</td><td align="center">public fifinal class StringBuffffer extends</td></tr></tbody></table><p>可以发现两个类都是”CharSequence”接口的子类。这个接口描述的是一系列的字符集。所以字符串是字符集的子</p><p>类，如果以后看见CharSequence，最简单的联想就是字符串。</p><p>注意：String和StringBuffffer类不能直接转换。如果要想互相转换，可以采用如下原则:</p><p>String变为StringBuffffer:利用StringBuffffer的构造方法或append()方法</p><p>StringBuffffer变为String:调用toString()方法。</p><p>除了append()方法外，StringBuffffer也有一些String类没有的方法:</p><p>字符串反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure><p><strong>代码示例:</strong> 字符串反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;helloworld&quot;</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(sb.reverse()); </span><br></pre></td></tr></table></figure><p>删除指定范围的数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span></span><br></pre></td></tr></table></figure><p><strong>代码示例:</strong> 观察删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;helloworld&quot;</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(sb.delete(<span class="number">5</span>, <span class="number">10</span>)); </span><br></pre></td></tr></table></figure><p>插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public synchronized StringBuffer insert(int offset, 各种数据类型 b) </span><br></pre></td></tr></table></figure><p><strong>代码示例:</strong> 观察插入操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;helloworld&quot;</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(sb.delete(<span class="number">5</span>, <span class="number">10</span>).insert(<span class="number">0</span>, <span class="string">&quot;你好&quot;</span>)); </span><br></pre></td></tr></table></figure><p><strong>面试题：请解释****String、StringBuffffer、StringBuilder的区别:</strong></p><blockquote><p>String的内容不可修改，StringBuffffer与StringBuilder的内容可以修改.</p><p>StringBuffffer与StringBuilder大部分功能是相似的</p><p>StringBuffffer采用同步处理，属于线程安全操作；而StringBuilder未采用同步处理，属于线程不安全操作</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程</title>
      <link href="/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/12/03/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包 (package) 是组织类的一种方式.</p><p>使用包的主要目的是保证类的唯一性</p><blockquote><p>例如, 你在代码中写了一个 Test 类. 然后你的同事也可能写一个 Test 类. 如果出现两个同名的类, 就会冲突, 导致代码不能编译通过</p></blockquote><h2 id="导入包中的类"><a href="#导入包中的类" class="headerlink" title="导入包中的类"></a>导入包中的类</h2><p>Java中提供了很多现成的类供给我们使用，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">        <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用<code>java.util.Date</code>这种方式引入 <code>java.util</code> 这个包中的 Date 类.</p><p>但是这种写法比较麻烦一些, 可以使用 import 语句导入包.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用<code> java.util</code> 中的其他类, 可以使用 <code>import java.util.*</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 得到一个毫秒级别的时间戳</span></span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们更建议显式的指定要导入的类名. 否则还是容易出现冲突的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// util 和 sql 中都存在一个 Date 这样的类, 此时就会出现歧义, 编译出错</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202112031330268.png" alt="image-20211203133041515"></p><blockquote><p>因为不知道调用的是哪个包里的<strong>Date</strong>，导致编译错误。</p></blockquote><p>在这种情况下需要使用完整的类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        java.util.Date date = <span class="keyword">new</span> java.util.Date();</span><br><span class="line">        System.out.println(date.getTime());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般的调用那个类，调用那个类，如果出现重复的类名的话，就需要使用完整的类名。</p></blockquote><h2 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h2><p>使用<code>import static</code> 可以导入包中的静态的方法和字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把类放入包中"><a href="#把类放入包中" class="headerlink" title="把类放入包中"></a>把类放入包中</h2><p><strong>基本规则</strong></p><blockquote><p>在文件的最上方加上一个 package 语句指定该代码在哪个包中.</p><p>包名需要尽量指定成唯一的名字, 通常会用公司的域名的颠倒形式(例如 com.yuyin.demo1 ).</p><p>包名要和代码路径相匹配. 例如创建 com.bit.demo1 的包, 那么会存在一个对应的路径 com/yuyin/demo1 来存储代码.</p><p>如果一个类没有 package 语句, 则该类被放到一个默认包中</p></blockquote><h2 id="包的访问权限控制"><a href="#包的访问权限控制" class="headerlink" title="包的访问权限控制"></a>包的访问权限控制</h2><blockquote><p>我们已经了解了类中的 public 和 private. private 中的成员只能被类的内部使用.</p><p>如果某个成员不包含 public 和 private 关键字, 此时这个成员可以在包内部的其他类使用, 但是不能在包外部的类使用.</p></blockquote><p>下面的代码给了一个示例. Demo1 和 Demo2 是同一个包中, Test 是其他包中.</p><p>Demo1.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuyin.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>Demo2.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuyin.demo; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Demo1 demo = <span class="keyword">new</span> Demo1(); </span><br><span class="line"> System.out.println(demo.value); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果, 能够访问到 value 变量</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>Test.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yuyin.demo.Demo1; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Demo1 demo = <span class="keyword">new</span> Demo1(); </span><br><span class="line"> System.out.println(demo.value); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">5</span>, <span class="number">32</span>) java: value在com.yuin.demo.Demo1中不是公共的; 无法从外部程序包中对其进行访问</span><br></pre></td></tr></table></figure><h2 id="常见的系统包"><a href="#常见的系统包" class="headerlink" title="常见的系统包"></a>常见的系统包</h2><ol><li><p><code>java.lang</code>:系统常用基础类(String、Object),此包从JDK1.1后自动导入。</p></li><li><p><code>java.lang.reflflect</code>:java 反射编程包;</p></li><li><p><code>java.net</code>:进行网络编程开发包。</p></li><li><p><code>java.sql</code>:进行数据库开发的支持包。</p></li><li><p><code>java.util</code>:是java提供的工具程序包。(集合类等) <strong>非常重要</strong></p></li><li><p><code>java.io</code>:I/O编程开发包</p></li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>代码中创建的类, 主要是为了抽象现实中的一些事物(包含属性和方法).</p><p>有的时候客观事物之间就存在一些关联关系, 那么在表示成类和对象的时候也会存在一定的关联.</p><p>例如, 设计一个类表示动物</p><blockquote><p> 我们可以给每个类创建一个单独的 java 文件. 类名必须和 .java 文件名匹配(大小写敏感)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="keyword">public</span> String name; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123; </span><br><span class="line"> <span class="keyword">public</span> String name; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123; </span><br><span class="line"> <span class="keyword">public</span> String name; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码我们发现其中存在了大量的冗余代码.</p><p>仔细分析, 我们发现 <code>Animal</code> 和 <code>Cat</code> 以及 <code>Bird</code> 这几个类中存在一定的关联关系:</p><blockquote><p>这三个类都具备一个相同的 eat 方法, 而且行为是完全一样的.</p><p>这三个类都具备一个相同的 name 属性, 而且意义是完全一样的.</p><p>从逻辑上讲, Cat 和 Bird 都是一种 Animal (is - a 语义).</p></blockquote><p>此时我们就可以让 Cat 和 Bird 分别继承 Animal 类, 来达到代码重用的效果.</p><p>此时, Animal 这样被继承的类, 我们称为 <strong>父类</strong> , <strong>基类</strong> 或 <strong>超类</strong>, 对于像 Cat 和 Bird 这样的类, 我们称为 <strong>子类</strong>, <strong>派生类</strong></p><p>和现实中的儿子继承父亲的财产类似, 子类也会继承父类的字段和方法, 以达到代码重用的效果</p><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p><strong>基本语法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 extends 指定父类.</p><p>Java 中一个子类只能继承一个父类 (而C++/Python等语言支持多继承).单继承</p><p>子类会继承父类的所有 public 的字段和方法.</p><p>对于父类的 private 的字段和方法, 子类中是无法访问的.</p><p>子类的实例中, 也包含着父类的实例. 可以使用 super 关键字得到父类实例的引用</p></blockquote><p>对于上面的代码, 可以使用继承进行改进. 此时我们让 Cat 和 Bird 继承自 Animal 类, 那么 Cat 在定义的时候就不必再写 name 字段和 eat 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  <span class="comment">//父类</span></span><br><span class="line"> <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">//子类</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 使用 super 调用父类的构造方法. </span></span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">//子类</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;小黑&quot;</span>); </span><br><span class="line"> cat.eat(<span class="string">&quot;猫粮&quot;</span>); </span><br><span class="line"> Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>); </span><br><span class="line"> bird.fly(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>extends 英文原意指 “扩展”. 而我们所写的类的继承, 也可以理解成基于父类进行代码上的 “扩展”.</p><p>例如我们写的 Bird 类, 就是在 Animal 的基础上扩展出了 flfly 方法</p></blockquote><p>如果我们把 name 改成 private, 那么此时子类就不能访问了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">19</span>, <span class="number">32</span>) java: name 在 Animal 中是 <span class="keyword">private</span> 访问控制</span><br></pre></td></tr></table></figure><h2 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h2><p>刚才我们发现, 如果把字段设为 private, 子类不能访问. 但是设成 public, 又违背了我们 “封装” 的初衷.</p><p>两全其美的办法就是 protected 关键字.</p><blockquote><p>对于类的调用者来说, protected 修饰的字段和方法是不能访问的</p><p>对于类的 <strong>子类</strong> 和 <strong>同一个包的其他类</strong> 来说, protected 修饰的字段和方法是可以访问的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="keyword">protected</span> String name; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 对于父类的 protected 字段, 子类可以正确访问</span></span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞 ︿(￣︶￣)︿&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Test.java 和 Animal.java 不在同一个 包 之中了. </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Animal animal = <span class="keyword">new</span> Animal(<span class="string">&quot;小动物&quot;</span>); </span><br><span class="line"> System.out.println(animal.name); <span class="comment">// 此时编译出错, 无法访问 name </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong>: Java 中对于字段和方法共有四种访问权限</p><blockquote><p>private: 类内部能访问, 类外部不能访问</p><p>默认(也叫包访问权限): 类内部能访问, 同一个包中的类可以访问, 其他类不能访问.</p><p>protected: 类内部能访问, 子类和同一个包中的类可以访问, 其他类不能访问.</p><p>public : 类内部和类的调用者都能访问</p></blockquote><p>四个访问权限修饰符的对比图：</p><table><thead><tr><th>访问权限</th><th>类</th><th>包</th><th>子类</th><th>其他包</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td><td>对任何人都是可用的</td></tr><tr><td>protect</td><td>√</td><td>√</td><td>√</td><td>×</td><td>继承的类可以访问以及和private一样的权限</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td><td>包访问权限，即在整个包内均可被访问</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td><td>类内部能访问, 类外部不能访问</td></tr></tbody></table><blockquote><p><strong>什么时候下用哪一种呢?</strong></p><p>我们希望类要尽量做到 “封装”, 即隐藏内部实现细节, 只暴露出 <strong>必要</strong> 的信息给类的调用者.</p><p>因此我们在使用的时候应该尽可能的使用 <strong>比较严格</strong> 的访问权限. 例如如果一个方法能用 private, 就尽量不要用public.</p><p>另外, 还有一种 <strong>简单粗暴</strong> 的做法: 将所有的字段设为 private, 将所有的方法设为 public. 不过这种方式属于是对访问权限的滥用, 还是更希望同学们能写代码的时候认真思考, 该类提供的字段方法到底给 “谁” 使用(是类内部自己用, 还是类的调用者使用, 还是子类使用)</p></blockquote><h2 id="更复杂的继承关系"><a href="#更复杂的继承关系" class="headerlink" title="更复杂的继承关系"></a>更复杂的继承关系</h2><blockquote><p>之前所有的例子都是直接继承的，但是现实中有许多的间接继承，例如动物有猫，狗，但是猫也分许多的种类，布偶，橘猫，然后细分的话又会有许多的子类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> Animal &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat.java </span></span><br><span class="line"><span class="keyword">public</span> Cat extends Animal &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ChineseGardenCat.java </span></span><br><span class="line"><span class="keyword">public</span> ChineseGardenCat extends Cat &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// OrangeCat.java </span></span><br><span class="line"><span class="keyword">public</span> Orange extends ChineseGardenCat &#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>如刚才这样的继承方式称为多层继承, 即子类还可以进一步的再派生出新的子类.</p><blockquote><p>时刻牢记, 我们写的类是现实事物的抽象. 而我们真正在公司中所遇到的项目往往业务比较复杂, 可能会涉及到一系列复杂的概念, 都需要我们使用代码来表示, 所以我们真实项目中所写的类也会有很多. 类之间的关系也会更加复杂.</p><p>但是即使如此, 我们并不希望类之间的继承层次太复杂. 一般我们不希望出现超过三层的继承关系. 如果继承层次太多, 就需要考虑对代码进行重构了.</p><p>如果想从语法上进行限制继承, 就可以使用 fifinal 关键字</p></blockquote><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>曾经我们学习过 final 关键字, 修饰一个变量或者字段的时候, 表示 <strong>常量</strong> (不能修改).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>; </span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure><p>final 关键字也能修饰类, 此时表示被修饰的类就不能被继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">3</span>, <span class="number">27</span>) java: 无法从最终com.yuyin.Animal进行继承</span><br></pre></td></tr></table></figure><blockquote><p>final 关键字的功能是 <strong>限制</strong> 类被继承</p><p>“限制” 这件事情意味着 “不灵活”. 在编程中, 灵活往往不见得是一件好事. 灵活可能意味着更容易出错.</p><p>是用 final 修饰的类被继承的时候, 就会编译报错, 此时就可以提示我们这样的继承是有悖这个类设计的初衷的.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202112031404230.png" alt="image-20211203140421155"></p><p>我们平时是用的 String 字符串类, 就是用 final 修饰的, 不能被继承</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>在刚才的例子里，我们写了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br></pre></td></tr></table></figure><p>同时这个代码可以写成如下样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br><span class="line">Animal bird2=bird;</span><br><span class="line"><span class="comment">//或者如下</span></span><br><span class="line">Animal bird2 = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时的Bird2就是父类的引用指向子类的对象，这种写法叫做向上转型</p><blockquote><p>向上转型这样的写法结合is-a语义来理解</p><p>圆圆是一只鸟，但它确实是一个动物</p></blockquote><p>向上转型发生的时机:</p><blockquote><p>直接赋值</p><p>方法传参</p><p>方法返回</p></blockquote><p><strong>方法传参</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br><span class="line">       feed( bird);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.eat(<span class="string">&quot;吃谷子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">圆圆正在吃谷子</span><br></pre></td></tr></table></figure><p>此时形参 animal 的类型是 Animal (基类), 实际上对应到 Bird (子类) 的实例</p><p><strong>方法返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Animal animal=findMyAnimal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">findMyAnimal</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Bird bird = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> bird;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时方法 <code>findMyAnimal</code> 返回的是一个 Animal 类型的引用, 但是实际上对应到 Bird 的实例.</p><h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>当子类和父类中出现同名方法的时候, 再去调用会出现什么情况呢?</p><p>对前面的代码稍加修改, 给 Bird 类也加上同名的 eat 方法, 并且在两个 eat 中分别加上不同的日志.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="keyword">protected</span> String name; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;我是一只小动物&quot;</span>); </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;我是一只小鸟&quot;</span>); </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Animal animal1 = <span class="keyword">new</span> Animal(<span class="string">&quot;圆圆&quot;</span>); </span><br><span class="line"> animal1.eat(<span class="string">&quot;谷子&quot;</span>); </span><br><span class="line"> Animal animal2 = <span class="keyword">new</span> Bird(<span class="string">&quot;扁扁&quot;</span>); </span><br><span class="line"> animal2.eat(<span class="string">&quot;谷子&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我是一只小动物</span><br><span class="line">圆圆正在吃谷子</span><br><span class="line">我是一只小鸟</span><br><span class="line">扁扁正在吃谷子</span><br></pre></td></tr></table></figure><p>此时, 我们发现:</p><blockquote><p>animal1 和 animal2 虽然都是 Animal 类型的引用, 但是 animal1 指向 Animal 类型的实例, animal2 指向Bird 类型的实例.</p><p>针对 animal1 和 animal2 分别调用 eat 方法, 发现 animal1.eat() 实际调用了父类的方法, 而animal2.eat() 实际调用了子类的方法.</p></blockquote><p>因此, 在 Java 中, 调用某个类的方法, 究竟执行了哪段代码 (是父类方法的代码还是子类方法的代码) , 要看究竟这个引用指向的是父类对象还是子类对象. 这个过程是程序运行时决定的(而不是编译期), 因此称为 <strong>动态绑定</strong>.</p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>针对刚才的 eat 方法来说:</p><p>子类实现父类的同名方法, 并且参数的类型和个数完全相同, 这种情况称为 <strong>覆写重写/覆盖(Override).</strong></p><p><strong>关于重写的注意事项</strong></p><ol><li>重写和重载完全不一样. 不要混淆</li><li>普通方法可以重写, static 修饰的静态方法不能重写.</li><li>重写中子类的方法的访问权限不能低于父类的方法访问权限.</li><li>重写的方法返回值类型不一定和父类的方法相同(但是建议最好写成相同, 特殊情况除外).</li></ol><p>重载和重写的区别：</p><p><strong>方法重载的规则：</strong></p><ul><li>方法名一致，参数列表中参数的顺序，类型，个数不同。</li><li>重载与方法的返回值无关，存在于父类和子类，同类中。</li><li>可以抛出不同的异常，可以有不同修饰符。</li></ul><p><strong>方法重写的规则：</strong></p><ul><li>参数列表、方法名、返回值类型必须完全一致；</li><li>构造方法不能被重写；</li><li>声明为 final 的方法不能被重写；</li><li>声明为 static 的方法不存在重写（重写和多态联合才有意义）；</li><li>访问权限不能比父类更低；</li><li>重写之后的方法不能抛出更宽泛的异常；</li></ul><h2 id="理解多态"><a href="#理解多态" class="headerlink" title="理解多态"></a>理解多态</h2><blockquote><p>最好理解就是实战</p></blockquote><p><strong>代码示例</strong>: 打印多种形状</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 啥都不用干</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;○&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;□&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flower</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;♣&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">====================================</span><br><span class="line"><span class="comment">// Test.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Shape shape1 = <span class="keyword">new</span> Flower(); </span><br><span class="line"> Shape shape2 = <span class="keyword">new</span> Cycle(); </span><br><span class="line"> Shape shape3 = <span class="keyword">new</span> Rect(); </span><br><span class="line"> drawMap(shape1); </span><br><span class="line"> drawMap(shape2); </span><br><span class="line"> drawMap(shape3); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 打印单个图形</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape shape)</span> </span>&#123; </span><br><span class="line"> shape.draw(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中, 分割线上方的代码是 <strong>类的实现者</strong> 编写的, 分割线下方的代码是 <strong>类的调用者</strong> 编写的.</p><p>当类的调用者在编写 <code>drawMap</code> 这个方法的时候, 参数类型为 Shape (父类), 此时在该方法内部并<strong>不知道,<strong>也</strong>不关注</strong>当前的 shape 引用指向的是哪个类型(哪个子类)的实例. 此时 shape 这个引用调用 draw 方法可能会有多种不同的表现(和 shape 对应的实例相关), 这种行为就称为<strong>多态</strong>.</p><blockquote><p>多态顾名思义, 就是 “一个引用, 能表现出多种不同形态”</p></blockquote><p><strong>使用多态的好处是什么?</strong></p><p><strong>1)</strong> <strong>类调用者对类的使用成本进一步降低.</strong></p><p>封装是让类的调用者不需要知道类的实现细节.</p><p>多态能让类的调用者连这个类的类型是什么都不必知道, 只需要知道这个对象具有某个方法即可.</p><p>因此, 多态可以理解成是封装的更进一步, 让类调用者对类的使用成本进一步降低.</p><p>这也贴合了 &lt;&lt;代码大全&gt;&gt; 中关于 “管理代码复杂程度” 的初衷.</p><p><strong>2)</strong> <strong>能够降低代码的</strong> <strong>“圈复杂度”,</strong> <strong>避免使用大量的</strong> <strong>if - else</strong></p><p>例如我们现在需要打印的不是一个形状了, 而是多个形状. 如果不基于多态, 实现代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawShapes</span><span class="params">()</span> </span>&#123; </span><br><span class="line">Rect rect = <span class="keyword">new</span> Rect(); </span><br><span class="line"> Cycle cycle = <span class="keyword">new</span> Cycle(); </span><br><span class="line"> Flower flower = <span class="keyword">new</span> Flower(); </span><br><span class="line"> String[] shapes = &#123;<span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;rect&quot;</span>, <span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;rect&quot;</span>, <span class="string">&quot;flower&quot;</span>&#125;; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (String shape : shapes) &#123; </span><br><span class="line"> <span class="keyword">if</span> (shape.equals(<span class="string">&quot;cycle&quot;</span>)) &#123; </span><br><span class="line"> cycle.draw(); </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equals(<span class="string">&quot;rect&quot;</span>)) &#123; </span><br><span class="line"> rect.draw(); </span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape.equals(<span class="string">&quot;flower&quot;</span>)) &#123; </span><br><span class="line"> flower.draw(); </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用使用多态, 则不必写这么多的 if - else 分支语句, 代码更简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawShapes</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 我们创建了一个 Shape 对象的数组. </span></span><br><span class="line"> Shape[] shapes = &#123;<span class="keyword">new</span> Cycle(), <span class="keyword">new</span> Rect(), <span class="keyword">new</span> Cycle(), </span><br><span class="line"> <span class="keyword">new</span> Rect(), <span class="keyword">new</span> Flower()&#125;; </span><br><span class="line"> <span class="keyword">for</span> (Shape shape : shapes) &#123; </span><br><span class="line"> shape.draw(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>什么叫 “圈复杂度” ?</p><p>圈复杂度是一种描述一段代码复杂程度的方式. 一段代码如果平铺直叙, 那么就比较简单容易理解. 而如果有很多的条件分支或者循环语句, 就认为理解起来更复杂.</p><p>因此我们可以简单粗暴的计算一段代码中条件语句和循环语句出现的个数, 这个个数就称为 “圈复杂度”. 如果一个方法的圈复杂度太高, 就需要考虑重构.</p><p>不同公司对于代码的圈复杂度的规范不一样. 一般不会超过 10</p></blockquote><p><strong>3)</strong> <strong>可扩展能力更强</strong><strong>.</strong></p><p>如果要新增一种新的形状, 使用多态的方式代码改动成本也比较低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;△&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对于类的调用者来说(<code>drawShape</code>s方法), 只要创建一个新类的实例就可以了, 改动成本很低.</p><p>而对于不用多态的情况, 就要把 <code>drawShapes</code> 中的 if - else 进行一定的修改, 改动成本更高</p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>向上转型是子类对象转成父类对象, 向下转型就是父类对象转成子类对象. 相比于向上转型来说, 向下转型没那么常见,但是也有一定的用途</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="keyword">protected</span> String name; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;我是一只小动物&quot;</span>); </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.java </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;我是一只小鸟&quot;</span>); </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在飞&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是我们熟悉的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Bird(<span class="string">&quot;圆圆&quot;</span>); </span><br><span class="line">animal.eat(<span class="string">&quot;谷子&quot;</span>); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">圆圆正在吃谷子</span><br></pre></td></tr></table></figure><p>接下来我们尝试让圆圆飞起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animal.fly(); </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">找不到 fly 方法</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>编译过程中, animal 的类型是 Animal, 此时编译器只知道这个类中有一个 eat 方法, 没有 fly 方法.</p><p>虽然 animal 实际引用的是一个 Bird 对象, 但是编译器是以 animal 的类型来查看有哪些方法的.</p><p>对于 <code>Animal animal = new Bird(&quot;圆圆&quot;)</code> 这样的代码,</p><blockquote><p>编译器检查有哪些方法存在, 看的是 Animal 这个类型</p><p>执行时究竟执行父类的方法还是子类的方法, 看的是 Bird 这个类型.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (Bird) 表示强制类型转换</span></span><br><span class="line">Bird bird = (Bird)animal; </span><br><span class="line">bird.fly(); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">圆圆正在飞</span><br></pre></td></tr></table></figure><p>但是这样的向下转型有时是不太可靠的. 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat(<span class="string">&quot;小猫&quot;</span>); </span><br><span class="line">Bird bird = (Bird)animal; </span><br><span class="line">bird.fly(); </span><br><span class="line"><span class="comment">// 执行结果, 抛出异常</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Cat cannot be cast to Bird </span><br><span class="line"> at Test.main(Test.java:<span class="number">35</span>) </span><br></pre></td></tr></table></figure><p>animal 本质上引用的是一个 Cat 对象, 是不能转成 Bird 对象的. 运行时就会抛出异常</p><p>所以, 为了让向下转型更安全, 我们可以先判定一下看看 animal 本质上是不是一个 Bird 实例, 再来转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Cat(<span class="string">&quot;小猫&quot;</span>); </span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird) &#123; </span><br><span class="line"> Bird bird = (Bird)animal; </span><br><span class="line"> bird.fly(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instanceof </code>可以判定一个引用是否是某个类的实例. 如果是, 则返回 true. 这时再进行向下转型就比较安全了</p><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>前面的代码中由于使用了重写机制, 调用到的是子类的方法. 如果需要在子类内部调用父类方法怎么办? 可以使用</p><p>super 关键字.</p><p><strong>super</strong> <strong>表示获取到父类实例的引用</strong>. 涉及到两种常见用法.</p><ol><li>使用了 super 来调用父类的构造器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 super 来调用父类的普通方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123; </span><br><span class="line"> <span class="comment">// 修改代码, 让子调用父类的接口. </span></span><br><span class="line"> <span class="keyword">super</span>.eat(food); </span><br><span class="line"> System.out.println(<span class="string">&quot;我是一只小鸟&quot;</span>); </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在吃&quot;</span> + food); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中, 如果在子类的 eat 方法中直接调用 eat (不加super), 那么此时就认为是调用子类自己的 eat (也就是递归了). 而加上 super 关键字, 才是调用父类的方法.</p><p>注意 super 和 this 功能有些相似, 但是还是要注意其中的区别</p><table><thead><tr><th align="center">No</th><th align="center">区别</th><th align="center">this</th><th align="center">super</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">概念</td><td align="center">访问本类中的属性和方法</td><td align="center">由子类访问父类中的属性和方法</td></tr><tr><td align="center">2</td><td align="center">查找范围</td><td align="center">先查找本类，如果本类没有就调用父类</td><td align="center">不查找本类而直接带哦用不累定义</td></tr><tr><td align="center">3</td><td align="center">特殊</td><td align="center">表示当前类</td><td align="center">无</td></tr></tbody></table><h2 id="在构造方法中调用重写的方法-一个坑"><a href="#在构造方法中调用重写的方法-一个坑" class="headerlink" title="在构造方法中调用重写的方法(一个坑)"></a>在构造方法中调用重写的方法(一个坑)</h2><p>一段有坑的代码. 我们创建两个类, B 是父类, D 是子类. D 中重写 <code>func</code> 方法. 并且在 B 的构造方法中调用 <code>func</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="comment">// do nothing </span></span><br><span class="line"> func(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;B.func()&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;D.func() &quot;</span> + num); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> D d = <span class="keyword">new</span> D();</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">D.func() <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>构造 D 对象的同时, 会调用 B 的构造方法.</p><p>B 的构造方法中调用了 func 方法, 此时会触发动态绑定, 会调用到 D 中的 func</p><p>此时 D 对象自身还没有构造, 此时 num 处在未初始化的状态, 值为 0.</p></blockquote><p><strong>结论</strong>: “用尽量简单的方式使对象进入可工作状态”, 尽量不要在构造器中调用方法(如果这个方法被子类重写, 就会触发动态绑定, 但是此时子类对象还没构造完成), 可能会出现一些隐藏的但是又极难发现的问题.</p><p><strong>总结</strong></p><p>多态是面向对象程序设计中比较难理解的部分. 我们会在后面的抽象类和接口中进一步体会多态的使用. 重点是多态带来的编码上的好处.</p><p>另一方面, 如果抛开 Java, 多态其实是一个更广泛的概念, 和 “继承” 这样的语法并没有必然的联系.</p><blockquote><p>C++ 中的 “动态多态” 和 Java 的多态类似. 但是 C++ 还有一种 “静态多态”(模板), 就和继承体系没有关系了.</p><p>Python 中的多态体现的是 “鸭子类型”, 也和继承体系没有关系.</p><p>Go 语言中没有 “继承” 这样的概念, 同样也能表示多态.</p></blockquote><p>无论是哪种编程语言, 多态的核心都是让调用者<strong>不必关注对象的具体类型</strong>. 这是降低用户使用成本的一种重要方式</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="语法规则-1"><a href="#语法规则-1" class="headerlink" title="语法规则"></a>语法规则</h2><p>在刚才的打印图形例子中, 我们发现, 父类 Shape 中的 draw 方法好像并没有什么实际工作, 主要的绘制图形都是由Shape 的各种子类的 draw 方法来完成的. 像这种没有实际工作的方法, 我们可以把它设计成一个 <strong>抽象方法(abstractmethod)</strong>, 包含抽象方法的类我们称为<strong>抽象类(abstract class)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 draw 方法前加上 abstract 关键字, 表示这是一个抽象方法. 同时抽象方法没有方法体(没有 { }, 不能执行具体代码).</p><p>对于包含抽象方法的类, 必须加上 abstract 关键字表示这是一个抽象类.</p></blockquote><p><strong>注意事项</strong></p><ol><li>抽象类不能直接实例化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape shape = <span class="keyword">new</span> Shape(); </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">30</span>, <span class="number">23</span>) java: Shape是抽象的; 无法实例化</span><br></pre></td></tr></table></figure><ol start="2"><li>抽象方法不能是 private 的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">abstract</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Error:(<span class="number">4</span>, <span class="number">27</span>) java: 非法的修饰符组合: <span class="keyword">abstract</span>和<span class="keyword">private</span></span><br></pre></td></tr></table></figure><blockquote><p>抽象类是不能够实例化的，如果实例方法是private类型，那么其方法就没有创造的意义</p></blockquote><ol start="3"><li><p>抽象类中可以包含其他的非抽象方法, 也可以包含字段. 这个非抽象方法和普通方法的规则都是一样的, 可以被重写,也可以被子类直接调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;func&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Shape shape = <span class="keyword">new</span> Rect(); </span><br><span class="line"> shape.func(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">func</span><br></pre></td></tr></table></figure></li></ol><h2 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h2><p>抽象类存在的最大意义就是<strong>为了被继承.</strong></p><p>抽象类本身<strong>不能被实例化</strong>, 要想使用, 只能创建该抽象类的子类. 然后让<strong>子类重写抽象类中的抽象方法</strong>.</p><blockquote><p> 疑问：普通的类也可以被继承呀, 普通的方法也可以被重写呀, 为啥非得用抽象类和抽象方法呢?</p></blockquote><p>确实如此. 但是使用抽象类相当于多了一重编译器的校验.</p><p>使用抽象类的场景就如上面的代码, 实际工作不应该由父类完成, 而应由子类完成. 那么此时如果不小心误用成父类了,</p><p>使用普通类编译器是不会报错的. 但是父类是抽象类就会在实例化的时候提示错误, 让我们尽早发现问题.</p><blockquote><p>很多语法存在的意义都是为了 “预防出错”, 例如我们曾经用过的 final 也是类似. 创建的变量用户不去修改, 不就相当于常量嘛? 但是加上 final 能够在不小心误修改的时候, 让编译器及时提醒我们.</p><p>充分利用编译器的校验, 在实际开发中是非常有意义的</p></blockquote><p>抽象类的大总结：</p><blockquote><ol><li>包含抽象方法的类，叫做抽象类</li><li>什么是抽象类，一个没有具体实现的方法，被abstract修饰。</li><li>抽象类是不可以被实例化的。</li><li>因为不可以被实例化，所以抽象类只能被继承。</li><li>抽象类中，也可以包含和普通类一样的成员和方法。</li><li>一个普通类，继承了一个抽象类，那么这个普通类必须重写抽象类中所有的抽象方法。</li><li>抽象类最大的作用就是被继承。</li><li>一个抽象类A，如果继承了一个抽象类B，那么这个抽象类A，可以不实现父类B的抽象方法。</li><li>结合第8点，当A类再次被一个普通类继承后，那么A和B这两个类中所有的抽象方法，必须被重写。</li><li>抽象列不能被final修饰，抽象方法也不可以被final修饰。</li></ol></blockquote><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是抽象类的更进一步. 抽象类中还可以包含非抽象方法, 和字段. 而接口中包含的<strong>方法都是抽象方法</strong>, <strong>字段只能包含静态常量</strong>.</p><h2 id="语法规则-2"><a href="#语法规则-2" class="headerlink" title="语法规则"></a>语法规则</h2><p>在刚才的打印图形的示例中, 我们的父类 Shape 并没有包含别的非抽象方法, 也可以设计成一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IShape</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;  <span class="comment">//完整就是abstract public void draw();</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> <span class="keyword">implements</span> <span class="title">IShape</span> </span>&#123; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;○&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> IShape shape = <span class="keyword">new</span> Rect(); </span><br><span class="line"> shape.draw(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用 interface 定义一个接口</p><p>接口中的方法一定是抽象方法, 因此可以省略 abstract</p><p>接口中的方法一定是 public, 因此可以省略 public</p><p>Cycle 使用 implements 继承接口. 此时表达的含义不再是 “扩展”, 而是 “实现”</p><p>在调用的时候同样可以创建一个接口的引用, 对应到一个子类的实例.</p><p>接口不能单独被实例化</p></blockquote><blockquote><p>扩展(extends) vs 实现(implements)</p><p>扩展指的是当前已经有一定的功能了, 进一步扩充功能.</p><p>实现指的是当前啥都没有, 需要从头构造出来</p></blockquote><p>接口中只能包含抽象方法. 对于字段来说, 接口中只能包含静态常量(final static).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IShape</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 public, static, final 的关键字都可以省略. 省略后的 <code>num</code> 仍然表示 public 的静态常量.</p><blockquote><p>提示:</p><ol><li><p>我们创建接口的时候, 接口的命名一般以大写字母 I 开头.</p></li><li><p>接口的命名一般使用 “形容词” 词性的单词.</p></li><li><p>阿里编码规范中约定, 接口中的方法和属性不要加任何修饰符号, 保持代码的简洁性</p></li></ol></blockquote><h2 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h2><p>有的时候我们需要让一个类同时继承自多个父类. 这件事情在有些编程语言通过 <strong>多继承</strong> 的方式来实现的.</p><p>然而 Java 中只支持单继承, 一个类只能 extends 一个父类. 但是可以同时实现多个接口, 也能达到多继承类似的效果.</p><p>现在我们通过类来表示一组动物.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="keyword">protected</span> String name; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们再提供一组接口, 分别表示 “会飞的”, “会跑的”, “会游泳的”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFlying</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们创建几个具体的动物</p><p>猫, 是会跑的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用四条腿跑&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鱼, 是会游的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用尾巴游泳&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>青蛙, 既能跑, 又能游(两栖动物)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">IRunning</span>, <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Frog</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在往前跳&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在蹬腿游泳&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种神奇的动物, 水陆空三栖, 叫做 “鸭子”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">IRunning</span>, <span class="title">ISwimming</span>, <span class="title">IFlying</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">super</span>(name); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用翅膀飞&quot;</span>); </span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用两条腿跑&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在漂在水上&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码展示了 Java 面向对象编程中最常见的用法: 一个类继承一个父类, 同时实现多种接口.</p><p>继承表达的含义是 <code>is - a</code> 语义, 而接口表达的含义是 具有 <code>xxx</code> 特性</p><blockquote><p>猫是一种动物, 具有会跑的特性.</p><p>青蛙也是一种动物, 既能跑, 也能游泳</p><p>鸭子也是一种动物, 既能跑, 也能游, 还能飞</p></blockquote><p>这样设计有什么好处呢? 时刻牢记多态的好处, 让程序猿<strong>忘记类型</strong>. 有了接口之后, 类的使用者就不必关注具体类型, 而只关注某个类是否具备某种能力.</p><p>例如, 现在实现一个方法, 叫 “散步”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(IRunning running)</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;我带着伙伴去散步&quot;</span>); </span><br><span class="line"> running.run(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 walk 方法内部, 我们并不关注到底是哪种动物, 只要参数是会跑的, 就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat(<span class="string">&quot;小猫&quot;</span>); </span><br><span class="line">walk(cat); </span><br><span class="line">Frog frog = <span class="keyword">new</span> Frog(<span class="string">&quot;小青蛙&quot;</span>); </span><br><span class="line">walk(frog); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我带着伙伴去散步</span><br><span class="line">小猫正在用四条腿跑</span><br><span class="line">我带着伙伴去散步</span><br><span class="line">小青蛙正在往前跳</span><br></pre></td></tr></table></figure><p>甚至参数可以不是 “动物”, 只要会跑!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> <span class="keyword">implements</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Robot</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;正在用轮子跑&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line">Robot robot = <span class="keyword">new</span> Robot(<span class="string">&quot;机器人&quot;</span>); </span><br><span class="line">walk(robot); </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">机器人正在用轮子跑</span><br></pre></td></tr></table></figure><h2 id="接口使用实例"><a href="#接口使用实例" class="headerlink" title="接口使用实例"></a>接口使用实例</h2><p><strong>给对象数组排序</strong></p><p>给定一个学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> score; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> <span class="keyword">this</span>.score = score; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.score + <span class="string">&quot;]&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再给定一个学生对象数组, 对这个对象数组中的元素进行排序(按分数降序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = <span class="keyword">new</span> Student[] &#123; </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">95</span>), </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">96</span>), </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>, <span class="number">97</span>), </span><br><span class="line"> <span class="keyword">new</span> Student(<span class="string">&quot;赵六&quot;</span>, <span class="number">92</span>), </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照我们之前的理解, 数组我们有一个现成的 sort 方法, 能否直接使用这个方法呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(students); </span><br><span class="line">System.out.println(Arrays.toString(students)); </span><br><span class="line"><span class="comment">// 运行出错, 抛出异常. </span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Student cannot be cast to java.lang.Comparable</span><br></pre></td></tr></table></figure><p>仔细思考, 不难发现, 和普通的整数不一样, 两个整数是可以直接比较的, 大小关系明确. 而两个学生对象的大小关系怎么确定? 需要我们额外指定.</p><p>让我们的 Student 类实现 <code>Comparable</code> 接口, 并实现其中的 <code>compareTo</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Comparable &#123; </span><br><span class="line"> private String name; </span><br><span class="line"> private int score; </span><br><span class="line"> public Student(String name, int score) &#123; </span><br><span class="line"> this.name = name; </span><br><span class="line"> this.score = score; </span><br><span class="line"> &#125; </span><br><span class="line"> @Override</span><br><span class="line">  public String toString() &#123; </span><br><span class="line"> return &quot;[&quot; + this.name + &quot;:&quot; + this.score + &quot;]&quot;; </span><br><span class="line"> &#125; </span><br><span class="line"> @Override </span><br><span class="line"> public int compareTo(Object o) &#123; </span><br><span class="line"> Student s = (Student)o; </span><br><span class="line"> if (this.score &gt; s.score) &#123; </span><br><span class="line"> return -1; </span><br><span class="line"> &#125; else if (this.score &lt; s.score) &#123; </span><br><span class="line"> return 1; </span><br><span class="line"> &#125; else &#123; </span><br><span class="line"> return 0; </span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sort 方法中会自动调用 <code>compareTo</code> 方法. <code>compareTo</code> 的参数是 Object , 其实传入的就是 Student 类型的对象.</p><p>然后比较当前对象和参数对象的大小关系(按分数来算).</p><blockquote><p>如果当前对象应排在参数对象之前, 返回小于 0 的数字;</p><p>如果当前对象应排在参数对象之后, 返回大于 0 的数字;</p><p>如果当前对象和参数对象不分先后, 返回 0;</p></blockquote><p>再次执行程序, 结果就符合预期了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">[[王五:<span class="number">97</span>], [李四:<span class="number">96</span>], [张三:<span class="number">95</span>], [赵六:<span class="number">92</span>]]</span><br></pre></td></tr></table></figure><h2 id="接口间的继承"><a href="#接口间的继承" class="headerlink" title="接口间的继承"></a>接口间的继承</h2><p>接口可以继承一个接口, 达到复用的效果. 使用 extends 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRunning</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 两栖的动物, 既能跑, 也能游</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAmphibious</span> <span class="keyword">extends</span> <span class="title">IRunning</span>, <span class="title">ISwimming</span> </span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">implements</span> <span class="title">IAmphibious</span> </span>&#123; </span><br><span class="line"> ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接口继承创建一个新的接口 <code>IAmphibious</code> 表示 “两栖的”. 此时实现接口创建的 Frog 类, 就继续要实现 run 方法,也需要实现 swim 方法.</p><blockquote><p>接口间的继承相当于把多个接口合并在一起</p></blockquote><p>接口的总结：</p><blockquote><ol><li>使用interface来修饰。interface IA{}</li><li>接口中的普通方法，不能有具体的实现，非要实现，只能通过关键字default来修饰这个方法。</li><li>接口当中，可以有static的方法。</li><li>里面所有的方法都是public的</li><li>抽象方法，默认是public abstract的</li><li>接口不可以通过关键字new来实例化。</li><li>类和接口之间的关系式通过<code>implemens</code>实现的</li><li>当一个类实现了一个接口，就必须要重写接口当中的抽象方法。</li><li>接口当中的成员变量默认是 <code>public static final</code>修饰的</li><li>当一个类实现一个接口后，重写这个方法的时候，这个方法前面必须加上public</li><li>一个类可以通过关键字extends继承一个抽象类或者普通类，但是只能继承一个类，同时可以用过implements实现多个接口，接口之间用逗号隔开。</li></ol></blockquote><h2 id="Clonable接口和深拷贝"><a href="#Clonable接口和深拷贝" class="headerlink" title="Clonable接口和深拷贝"></a>Clonable接口和深拷贝</h2><p>Java 中内置了一些很有用的接口, Clonable 就是其中之一.</p><p>Object 类中存在一个 clone 方法, 调用这个方法可以创建一个对象的 “拷贝”. 但是要想合法调用 clone 方法, 必须要先</p><p>实现 Clonable 接口, 否则就会抛出 CloneNotSupportedException 异常.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name; </span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Animal <span class="title">clone</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> Animal o = <span class="keyword">null</span>; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> o = (Animal)<span class="keyword">super</span>.clone(); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">      e.printStackTrace(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> o; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Animal animal = <span class="keyword">new</span> Animal(); </span><br><span class="line"> Animal animal2 = animal.clone(); </span><br><span class="line"> System.out.println(animal == animal2); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝 VS 深拷贝</p><p>Cloneable 拷贝出的对象是一份 “浅拷贝”</p><p>观察以下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> A <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line"><span class="keyword">return</span> (A)<span class="keyword">super</span>.clone(); </span><br><span class="line">&#125; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line"><span class="keyword">public</span> A a = <span class="keyword">new</span> A(); </span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">           <span class="keyword">return</span> (B)<span class="keyword">super</span>.clone(); </span><br><span class="line">       &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123; </span><br><span class="line">B b = <span class="keyword">new</span> B(); </span><br><span class="line">B b2 = b.clone(); </span><br><span class="line">b.a.num = <span class="number">10</span>; </span><br><span class="line">System.out.println(b2.a.num); </span><br><span class="line">&#125; </span><br><span class="line">&gt;&#125; </span><br><span class="line">&gt;<span class="comment">// 执行结果</span></span><br><span class="line">&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure><p>通过 clone 拷贝出的 b 对象只是拷贝了 b 自身, 而没有拷贝内部包含的 a 对象. 此时 b 和 b2 中包含的 a 引用仍然是指向同一个对象. 此时修改一边, 另一边也会发生改变.</p></blockquote><p><strong>总结</strong></p><p>抽象类和接口都是 Java 中多态的常见使用方式. 都需要重点掌握. 同时又要认清两者的区别(重要!!! 常见面试题).</p><p><strong>核心区别</strong>: 抽象类中可以包含普通方法和普通字段, 这样的普通方法和字段可以被子类直接使用(不必重写), 而接口中不能包含普通方法, 子类必须重写所有的抽象方法.</p><p>如之前写的 Animal 例子. 此处的 Animal 中包含一个 name 这样的属性, 这个属性在任何子类中都是存在的. 因此此处的 Animal 只能作为一个抽象类, 而不应该成为一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"> <span class="keyword">protected</span> String name; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再次提醒:</p><p>抽象类存在的意义是为了让编译器更好的校验, 像 Animal 这样的类我们并不会直接使用, 而是使用它的子类. 万一不小心创建了 Animal 的实例, 编译器会及时提醒我们</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>类和对象</title>
      <link href="/2021/12/01/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/12/01/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象的初步认知"><a href="#类和对象的初步认知" class="headerlink" title="类和对象的初步认知"></a>类和对象的初步认知</h1><p>C语言是<strong>面向对象</strong>的，<strong>关注</strong>的是过程，分析出求解问题的步骤，通过函数调用逐步解决问题。</p><p>Java是基<strong>于面向对象</strong>的，<strong>关注</strong>的是对象，讲一件事情拆分为不同的对象，通过对象之间的交互完成</p><p><strong>面向过程</strong>注重的是过程，在整个过程中所涉及的行为，都是功能。</p><p><strong>面向对象</strong>注重的是对象，也就是参与过程的所涉及的各个主体。通过逻辑将所有的功能实现连接在一起。</p><p>实例：大象装进冰箱</p><blockquote><p>面向过程：1.把冰箱门打开 2 把大象装进冰箱 3 关上冰箱门</p><p><strong>面向过程</strong>： 冰箱：打开冰箱门，关闭冰箱门   </p><p>​                        大象 ：进入冰箱</p></blockquote><p><strong>【面向对象概念】</strong></p><p>1.面向对象是思考问题的一种思考方式，是一种思想。比如：概念与实例。理论与实践。名和实等等。</p><p>2.类就是一类对象的统称。对象就是这一类具体化的一个实例。</p><p>3.面向对象的好处：将复杂的事情变简单了，只要面对一个对象就行。</p><p><strong>【面向对象设计】</strong></p><p>面向对象设计把握一个重要的经验：谁拥有数据，谁对外提供操作这些数据（私有）的方法！</p><p>（被动的一方是数据的拥有者，主动的一方是执行者）</p><p><strong>开发时：找对象，建对象，用对象，并维护对象之间的关系。</strong></p><blockquote><p>万物皆对象</p></blockquote><p><strong>简而言之</strong></p><p>面向对象就是用代码(类)来描述客观世界的事物的一种方式. 一个类主要包含一个事物的属性和行为</p><h1 id="类和类的实例化"><a href="#类和类的实例化" class="headerlink" title="类和类的实例化"></a>类和类的实例化</h1><blockquote><p>问：什么是类，什么是对象？</p></blockquote><p><strong>类就是一类对象的统称。对象就是这一类具体化的一个实例</strong></p><p>类的声明和实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;<span class="title">class_name</span>&gt;</span>&#123;  </span><br><span class="line">    field;<span class="comment">//成员属性</span></span><br><span class="line">    method;<span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line">&lt;class_name&gt; &lt;对象名&gt; = <span class="keyword">new</span> &lt;class_name&gt;();</span><br></pre></td></tr></table></figure><p><strong>class</strong>为定义类的关键字，<code>ClassName</code>为类的名字，{}中为类的主体。</p><p>类中的元素称为：成员属性。类中的函数称为：成员方法。</p><blockquote><p>Java是面向对象的编程，所以我们做任何事情都需要找对象，而对象确是类实例而来的，所以我们又需要创建一个类，有了类就可以实例化一个对象供我们使用</p></blockquote><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;<span class="comment">//成员属性 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;<span class="comment">//成员方法</span></span><br><span class="line">       System.out.println(<span class="string">&quot;吃饭!&quot;</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;睡觉!&quot;</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的实例化</strong></p><p><strong>用类类型创建对象的过程，称为类的实例化</strong></p><ol><li><p><strong>类只是</strong>一个<strong>模型</strong>一样的东西，限定了类有哪些成员.</p></li><li><p>一个类可以实例化出多个对象，<strong>实例化出的对象 占用实际的物理空间，存储类成员变量</strong></p></li><li><p>做个比方。<strong>类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</strong>，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</p></li></ol><blockquote><p>又好像，所有人是一个类，拥有姓名，年龄等属性，每一个具体的人又是一个对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;<span class="comment">//成员属性 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String sex;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;<span class="comment">//成员方法</span></span><br><span class="line">       System.out.println(<span class="string">&quot;吃饭!&quot;</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;睡觉!&quot;</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();<span class="comment">//通过new实例化对象</span></span><br><span class="line">        person.eat();<span class="comment">//成员方法调用需要通过对象的引用调用</span></span><br><span class="line">        person.sleep();</span><br><span class="line">        <span class="comment">//产生对象     实例化对象</span></span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person3 = <span class="keyword">new</span> Person();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>输出结果:</p><p>吃饭！</p><p>睡觉</p></blockquote><p><strong>注意事项</strong></p><blockquote><p>new 关键字用于创建一个对象的实例.</p><p>使用 “ . “来访问对象中的属性和方法.</p><p>同一个类可以创建对个实例</p></blockquote><h1 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h1><p>类的成员可以包含以下：字段、方法、代码块、内部类和接口等</p><h2 id="字段-属性-成员变量"><a href="#字段-属性-成员变量" class="headerlink" title="字段/属性/成员变量"></a>字段/属性/成员变量</h2><blockquote><p>属性和方法：比如人这个类，我们每一个人都有名字，年龄等属性，同时也拥有吃饭和睡觉这样的行为方法</p></blockquote><p>在类中, 但是方法外部定义的变量. 这样的变量我们称为 “字段” 或 “属性” 或 “成员变量”(三种称呼都可以, 一般不会严格区分)</p><blockquote><p>与只想对应的还有局部变量，定义在方法里面的叫做局部变量，两者的区别就是位置不同。</p><p>局部变量的声明必须初始化。</p></blockquote><p>用于描述一个类中包含哪些数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;   <span class="comment">// 字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><blockquote><p>使用 . 访问对象的字段. </p><p>“访问” 既包含读, 也包含写.</p><p>对于一个对象的字段如果没有显式设置初始值, 那么会被设置一个默认的初值</p></blockquote><p>​    默认值规则</p><blockquote><p>对于整数类型，默认值为0</p><p>对于浮点类型，默认值为0.0</p><p>对于boolean类型，默认值为false</p><p>对于char类型，默认值为0( ‘ \u0000 ‘ )</p><p>对于引用类型，默认值为null</p></blockquote><p><strong>认识</strong> <strong>null</strong></p><p>null 在 Java 中为 “空引用”, 表示不引用任何对象。如果对null进行 <code>. </code>操作就会引发异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name.length());   <span class="comment">// 获取字符串长度</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">        at Test.main(Test.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p><strong>字段就地初始化</strong></p><p>很多时候我们不希望字段使用默认值, 而是需要我们显式设定初值. 可以这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">张三</span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>就是我们曾经讲过的方法.用于描述一个对象的行为.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;, 今年&quot;</span> + age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我叫张三, 今年<span class="number">18</span>岁</span><br></pre></td></tr></table></figure><p>此处的 show 方法, 表示 Person 这个对象具有一个 “展示自我” 的行为.</p><p>这样的 show 方法是和 person 实例相关联的. 如果创建了其他实例, 那么 show 的行为就会发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">person2.age = <span class="number">20</span>;</span><br><span class="line">person2.show()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我叫李四, 今年<span class="number">20</span>岁</span><br></pre></td></tr></table></figure><p>方法中还有一种特殊的方法称为 <strong>构造方法</strong> <strong>(construction method)</strong></p><p>在实例化对象的时候会被自动调用到的方法, 方法名字和类名相同, 用于对象的初始化.</p><p>虽然我们前面已经能将属性就地初始化, 但是有些时候可能需要进行一些更复杂的初始化逻辑, 那么就可以使用构造方法.</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><blockquote><p>1、修饰属性</p><p>2、修饰方法</p><p>3、代码块</p><p>4、修饰类</p></blockquote><p><strong>a)</strong> <strong>修饰属性</strong>，Java静态属性和类相关, 和具体的实例无关. 换句话说, 同一个类的不同实例共用同一个静态属性.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestDemo t1 = <span class="keyword">new</span> TestDemo();</span><br><span class="line">        t1.a++;</span><br><span class="line">        TestDemo.count++;</span><br><span class="line">        System.out.println(t1.a);</span><br><span class="line">        System.out.println(TestDemo.count);</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        TestDemo t2 = <span class="keyword">new</span> TestDemo();</span><br><span class="line">        t2.a++;</span><br><span class="line">        TestDemo.count++;</span><br><span class="line">        System.out.println(t2.a);</span><br><span class="line">        System.out.println(TestDemo.count);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202112011644419.png" alt="image-20211201164427267"></p><p><strong>示例代码内存解析：</strong>count被static所修饰，所有类共享。且不属于对象，访问方式为：类名 <strong>.</strong> <strong>属性。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202112011652842.png" alt="image-20211201165200741"></p><p><strong>b)</strong> <strong>修饰方法</strong></p><p>如果在任何方法上应用 static 关键字，此方法称为静态方法。</p><blockquote><p>静态方法属于类，而不属于类的对象。</p><p>可以直接调用静态方法，而无需创建类的实例。</p><p>静态方法可以访问静态数据成员，并可以更改静态数据成员的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//a = 10; error 不可以访问非静态数据成员</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestDemo.change()；<span class="comment">//无需创建实例对象 就可以调用</span></span><br><span class="line">        System.out.println(TestDemo.count);   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>*<em>注意事项1</em>: 静态方法和实例无关, 而是和类相关. 因此这导致了这个情况:</p><blockquote><p>静态方法不能直接使用非静态数据成员或调用非静态方法(非静态数据成员和方法都是和实例相关的).</p><p>this和super两个关键字不能在静态上下文中使用(this 是当前实例的引用, super是当前实例父类实例的引用, 也是和当前实例相关).</p></blockquote><blockquote><p>静态方法中，只能调用静态的方法或属性<br>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p></blockquote><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><blockquote><p><strong>什么叫封装</strong>?</p><p>&lt;&lt;代码大全&gt;&gt; 开篇就在讨论一个问题: 软件开发的本质就是对程序复杂程度的管理. 如果一个软件代码复杂程</p><p>度太高, 那么就无法继续维护. 如何管理复杂程度? 封装就是最基本的方法.</p><p>在我们写代码的时候经常会涉及两种角色: <strong>类的实现者</strong>和<strong>类的调用者</strong>.</p><p>封装的本质就是让类的调用者不必太多的了解类的实现者是如何实现类的, 只要知道如何使用类就行了.</p><p>这样就降低了类使用者的学习和使用成本, 从而降低了复杂程度</p></blockquote><blockquote><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；<br>低耦合 ：仅对外暴露少量的方法用于使用。</p></blockquote><h2 id="private实现封装"><a href="#private实现封装" class="headerlink" title="private实现封装"></a>private实现封装</h2><p>private/public两个关键字表示“访问权限控制”</p><blockquote><p>被 public 修饰的成员变量或者成员方法, 可以直接被类的调用者使用. </p><p>被 private 修饰的成员变量或者成员方法, 不能被类的调用者使用</p></blockquote><p><strong>直接使用</strong> <strong>public</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫&quot;</span> + person.name + <span class="string">&quot;, 今年&quot;</span> + person.age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我叫张三, 今年<span class="number">18</span>岁</span><br></pre></td></tr></table></figure><p>这样的代码导致类的使用者(main方法的代码)必须要了解 Person 类内部的实现, 才能够使用这个类. 学习成本较</p><p>高</p><p>一旦类的实现者修改了代码(例如把 name 改成 myName), 那么类的使用者就需要大规模的修改自己的代码, 维</p><p>护成本较高.</p><p>范例：使用 private 封装属性, 并提供 public 方法供类的调用者使用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name = <span class="string">&quot;张三&quot;</span>; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">18</span>; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;, 今年&quot;</span> + age + <span class="string">&quot;岁&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Person person = <span class="keyword">new</span> Person(); </span><br><span class="line"> person.show(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">我叫张三, 今年<span class="number">18</span>岁</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时字段已经使用 private 来修饰. 类的调用者(main方法中)不能直接使用. 而需要借助 show 方法. 此时类的使用者就不必了解 Person 类的实现细节.</p><p>同时如果类的实现者修改了字段的名字, 类的调用者不需要做出任何修改(类的调用者根本访问不到 name, age这样的字段).</p><blockquote><p>那么问题来了~~ 类的实现者万一修改了 public 方法 show 的名字, 岂不是类的调用者仍然需要大量修改代码嘛?</p><p>这件事情确实如此, 但是一般很少会发生. 一般类的设计都要求类提供的 public 方法能比较稳定, 不应该频繁发生大的改变. 尤其是对于一些基础库中的类, 更是如此. 每次接口的变动都要仔细考虑兼容性问题.</p></blockquote><p><strong>注意事项</strong></p><blockquote><p>private 不光能修饰字段, 也能修饰方法</p><p>通常情况下我们会把字段设为 private 属性, 但是方法是否需要设为 public, 就需要视具体情形而定. 一般我们希望一个类只提供 “必要的” public 方法, 而不应该是把所有的方法都无脑设为 public.</p></blockquote><h2 id="getter和setter方法"><a href="#getter和setter方法" class="headerlink" title="getter和setter方法"></a><strong>getter和setter方法</strong></h2><p>当我们使用 private 来修饰字段的时候, 就无法直接使用这个字段了</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name = <span class="string">&quot;张三&quot;</span>; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">18</span>; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;, 今年&quot;</span> + age + <span class="string">&quot;岁&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Person person = <span class="keyword">new</span> Person(); </span><br><span class="line"> person.age = <span class="number">20</span>; </span><br><span class="line"> person.show(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Test.java:<span class="number">13</span>: 错误: age可以在Person中访问<span class="keyword">private</span> </span><br><span class="line"> person.age = <span class="number">20</span>; </span><br><span class="line"> ^ </span><br><span class="line"><span class="number">1</span> 个错误</span><br></pre></td></tr></table></figure><p>此时如果需要获取或者修改这个 private 属性, 就需要使用 getter / setter 方法.</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name;<span class="comment">//实例成员变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123; </span><br><span class="line"> <span class="comment">//name = name;//不能这样写</span></span><br><span class="line"> <span class="keyword">this</span>.name = name;<span class="comment">//this引用，表示调用该方法的对象</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; </span><br><span class="line"> <span class="keyword">return</span> name; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name: &quot;</span>+name+<span class="string">&quot; age: &quot;</span>+age); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Person person = <span class="keyword">new</span> Person(); </span><br><span class="line"> person.setName(<span class="string">&quot;caocao&quot;</span>); </span><br><span class="line"> String name = person.getName(); </span><br><span class="line"> System.out.println(name); </span><br><span class="line"> person.show(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">caocao </span><br><span class="line">name: caocao age: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><blockquote><p>getName 即为 getter 方法, 表示获取这个成员的值.</p><p>setName 即为 setter 方法, 表示设置这个成员的值</p><p>当set方法的形参名字和类中的成员属性的名字一样的时候，如果不使用this, 相当于自赋值. this 表示当前实例的引用.</p><p>不是所有的字段都一定要提供 setter / getter 方法, 而是要根据实际情况决定提供哪种方法. </p><p>在 IDEA 中可以使用 alt + insert (或者 alt + F12) 快速生成 setter / getter 方法. </p></blockquote><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>构造方法是一种特殊方法，使用关键字new实例化新对象会被调用，用于完成初始化操作</p><p><strong>new</strong> <strong>执行过程</strong></p><p>为对象分配内存空间</p><p>调用对象的构造方法</p><p><strong>语法规则</strong></p><ol><li><p>方法名称必须与类名称相同</p></li><li><p>构造方法没有返回值类型声明</p></li><li><p>每一个类中一定至少存在一个构造方法（没有明确定义，则系统自动生成一个无参构造）</p></li></ol><p><strong>注意事项</strong></p><blockquote><p>如果类中没有提供任何的构造函数，那么编译器会默认生成一个不带有参数的构造函数</p><p>若类中定义了构造方法，则默认的无参构造将不再生成.</p><p>构造方法支持重载. 规则和普通方法的重载一致.</p></blockquote><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name;<span class="comment">//实例成员变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"> <span class="keyword">private</span> String sex; </span><br><span class="line">    </span><br><span class="line"> <span class="comment">//默认构造函数 构造对象 </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">&quot;caocao&quot;</span>; </span><br><span class="line"> <span class="keyword">this</span>.age = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">this</span>.sex = <span class="string">&quot;男&quot;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="comment">//带有3个参数的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age,String sex)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name; </span><br><span class="line"><span class="keyword">this</span>.age = age; </span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name: &quot;</span>+name+<span class="string">&quot; age: &quot;</span>+age+<span class="string">&quot; sex: &quot;</span>+sex); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();<span class="comment">//调用不带参数的构造函数 如果程序没有提供会调用不带参数的构造函数</span></span><br><span class="line">p1.show(); </span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;zhangfei&quot;</span>,<span class="number">80</span>,<span class="string">&quot;男&quot;</span>);<span class="comment">//调用带有3个参数的构造函数</span></span><br><span class="line">p2.show(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">name: caocao age: <span class="number">10</span> sex: 男</span><br><span class="line">name: zhangfei age: <span class="number">80</span> sex: 男</span><br></pre></td></tr></table></figure><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this表示当前对象引用(注意不是当前对象)，可以借助this来访问对象的属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//实例成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"><span class="keyword">private</span> String sex; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//默认构造函数 构造对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="comment">//this调用构造函数</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;yuyin&quot;</span>, <span class="number">12</span>, <span class="string">&quot;man&quot;</span>);<span class="comment">//必须放在第一行进行显示</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//这两个构造函数之间的关系为重载。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age,String sex)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.sex = sex; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name: &quot;</span>+name+<span class="string">&quot; age: &quot;</span>+age+<span class="string">&quot; sex: &quot;</span>+sex); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Person person = <span class="keyword">new</span> Person();<span class="comment">//调用不带参数的构造函数</span></span><br><span class="line"> person.show(); </span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">name: yuin age: <span class="number">12</span> sex: man</span><br></pre></td></tr></table></figure><blockquote><p>我们会发现在构造函数的内部，我们可以使用this关键字，构造函数是用来构造对象的，对象还没有构造好，</p><p>我们就使用了this，那this还代表当前对象吗？当然不是，this代表的是当前对象的引用</p></blockquote><blockquote><ol><li>我们在类的构造函数中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造函数</li><li>构造函数中不能通过”this(形参列表)”方式调用自己</li><li> 如果一个类中有n个构造函数，则最多有 n - 1构造函数中使用了”this(形参列表)”</li><li> 规定：”this(形参列表)”必须声明在当前构造函数的首行</li><li> 构造函数内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造函数</li></ol></blockquote><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>字段的初始化方式有：</p><ol><li><p>就地初始化</p></li><li><p>使用构造方法初始化</p></li><li><p>使用代码块初始化</p></li></ol><h2 id="什么是代码块"><a href="#什么是代码块" class="headerlink" title="什么是代码块"></a><strong>什么是代码块</strong></h2><p>使用 {} 定义的一段代码.</p><p>根据代码块定义的位置以及关键字，又可分为以下四种：</p><blockquote><p>普通代码块</p><p>构造块</p><p>静态块</p><p>同步代码块</p></blockquote><h2 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h2><p>普通代码块：定义在方法中的代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">&#123; <span class="comment">//直接使用&#123;&#125;定义，普通方法块</span></span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">10</span> ; </span><br><span class="line"> System.out.println(<span class="string">&quot;x1 = &quot;</span> +x); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">int</span> x = <span class="number">100</span> ; </span><br><span class="line"> System.out.println(<span class="string">&quot;x2 = &quot;</span> +x); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">x1 = <span class="number">10</span> </span><br><span class="line">x2 = <span class="number">100</span></span><br></pre></td></tr></table></figure><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><p>构造块：定义在类中的代码块(不加修饰符)。也叫：<strong>实例代码块</strong>。构造代码块一般用于初始化实例成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name;<span class="comment">//实例成员变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"> <span class="keyword">private</span> String sex; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;I am Person init()!&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="comment">//实例代码块</span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">&quot;yuyin&quot;</span>; </span><br><span class="line"> <span class="keyword">this</span>.age = <span class="number">18</span>; </span><br><span class="line"> <span class="keyword">this</span>.sex = <span class="string">&quot;man&quot;</span>; </span><br><span class="line"> System.out.println(<span class="string">&quot;I am instance init()!&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name: &quot;</span>+name+<span class="string">&quot; age: &quot;</span>+age+<span class="string">&quot; sex: &quot;</span>+sex); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Person p1 = <span class="keyword">new</span> Person(); </span><br><span class="line"> p1.show(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="function">I am instance <span class="title">init</span><span class="params">()</span>! </span></span><br><span class="line"><span class="function">I am Person <span class="title">init</span><span class="params">()</span>! </span></span><br><span class="line"><span class="function">name: yuyin age: 18 sex: man</span></span><br></pre></td></tr></table></figure><p><strong>注意事项:</strong> 实例代码块优先于构造函数执行</p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>使用static定义的代码块。<strong>一般用于初始化静态成员属性。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//实例成员变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"> <span class="keyword">private</span> String sex; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//静态成员变量 由类共享数据 方法区</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;I am Person init()!&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//实例代码块</span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">&quot;bit&quot;</span>; </span><br><span class="line"> <span class="keyword">this</span>.age = <span class="number">12</span>; </span><br><span class="line"> <span class="keyword">this</span>.sex = <span class="string">&quot;man&quot;</span>; </span><br><span class="line"> System.out.println(<span class="string">&quot;I am instance init()!&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//静态代码块</span></span><br><span class="line"> <span class="keyword">static</span> &#123; </span><br><span class="line"> count = <span class="number">10</span>;<span class="comment">//只能访问静态数据成员 </span></span><br><span class="line"> System.out.println(<span class="string">&quot;I am static init()!&quot;</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name: &quot;</span>+name+<span class="string">&quot; age: &quot;</span>+age+<span class="string">&quot; sex: &quot;</span>+sex); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Person p1 = <span class="keyword">new</span> Person(); </span><br><span class="line"> Person p2 = <span class="keyword">new</span> Person();<span class="comment">//静态代码块是否还会被执行？</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><blockquote><p>静态代码块不管生成多少个对象，其只会执行一次，且是最先执行的。</p><p><strong>静态代码块</strong>执行完毕后, <strong>实例代码块（构造块）</strong>执行，再然后是<strong>构造函数</strong>执行。</p></blockquote><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>当我们使用输出语句的时候，其实是调用的toString方法，我们重写toString后就可以输出我们想输出的样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name:&quot;</span>+name+<span class="string">&quot; &quot;</span> + <span class="string">&quot;age:&quot;</span>+age); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> Person person = <span class="keyword">new</span> Person(<span class="string">&quot;caocao&quot;</span>,<span class="number">19</span>); </span><br><span class="line"> person.show(); </span><br><span class="line"> <span class="comment">//我们发现这里打印的是一个地址的哈希值 原因：调用的是Object的toString方法</span></span><br><span class="line"> System.out.println(person); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">name：caocao age：<span class="number">19</span> </span><br><span class="line">Person@1c168e5</span><br></pre></td></tr></table></figure><p>以使用 toString 这样的方法来将对象自动转成字符串.</p><p><strong>代码示例:</strong>    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line">&#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name:&quot;</span>+name+<span class="string">&quot; &quot;</span> + <span class="string">&quot;age:&quot;</span>+age); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">//重写Object的toString方法</span></span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + </span><br><span class="line"> <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + </span><br><span class="line"> <span class="string">&quot;, age=&quot;</span> + age + </span><br><span class="line"> <span class="string">&#x27;&#125;&#x27;</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;caocao&quot;</span>,<span class="number">19</span>); </span><br><span class="line"> person.show(); </span><br><span class="line"> System.out.println(person); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">name：caocao age：<span class="number">19</span> </span><br><span class="line">Person&#123;name=<span class="string">&#x27;caocao&#x27;</span>, age=<span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项:</strong></p><blockquote><p>toString 方法会在 println 的时候被自动调用.</p><p>将对象转成字符串这样的操作我们称为 <strong>序列化</strong>.</p><p>toString 是 Object 类提供的方法, 我们自己创建的 Person 类默认继承自 Object 类, 可以重写 toString 方法实</p><p>现我们自己版本的转换字符串方法. (关于继承和重写这样的概念, 我们后面会重点介绍).</p><p>@Override 在 Java 中称为 “注解”, 此处的 @Override 表示下面实现的 toString 方法是重写了父类的方法. 关于</p><p>注解后面的课程会详细介绍.</p><p>IDEA快速生成Object的toString方法快捷键：alt+f12(insert)</p></blockquote><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>匿名只是表示没有名字的对象.</p><blockquote><p>没有引用的对象称为匿名对象.</p><p>匿名对象只能在创建对象时使用.</p><p>如果一个对象只是用一次, 后面不需要用了, 可以考虑使用匿名对象</p></blockquote><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line"> <span class="keyword">private</span> String name; </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.age = age; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> System.out.println(<span class="string">&quot;name:&quot;</span>+name+<span class="string">&quot; &quot;</span> + <span class="string">&quot;age:&quot;</span>+age); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">new</span> Person(<span class="string">&quot;caocao&quot;</span>,<span class="number">19</span>).show();<span class="comment">//通过匿名对象调用方法</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">name：caocao age：<span class="number">19</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构LeetCode</title>
      <link href="/2021/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84LeetCode/"/>
      <url>/2021/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84LeetCode/</url>
      
        <content type="html"><![CDATA[<h1 id="第一天-数组"><a href="#第一天-数组" class="headerlink" title="第一天 数组"></a>第一天 数组</h1><h2 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h2><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202111302104495.png" alt="image-20211130210153468"></p><blockquote><p>首先分析题目，需要在数组寻找两个一样的数组，如果存在这样的数据，就返回true，没有的话，就返回false</p></blockquote><blockquote><p>解法一：排序</p><p>可以借助<code>Arrays.sort()</code>方法对数组进行排序，最后使用for循环对相邻的两个元素进行判断，如果相同就返回true，循环结束后没有找到相同的两个元素的话，就返回false</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：因为要比较两个相邻的元素，比较的最后一个元素必须是倒数第二个，否则会报空指针异常。</p></blockquote><blockquote><p>解法二：哈希表</p><p>我们创建一个哈希表用来保存数组中的所有元素，通过循环，如果发现已经保存过这个元素，我们就返回true，表示数组中有重复值，否则就返回false</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line"><span class="keyword">if</span>(!set.add(x))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202111302117854.png" alt="image-20211130211700790"></p><blockquote><p>题目分析：</p><p>在一个数组中寻找最大的连续子数组，并且输出其和。</p><p>使用动态规划，一边做循环，一边寻找最大和。用两个变量，变量1来保存最大值，变量2进行相邻元素之间的加法，最后将当前的最大值和相邻变量进行加法运算后的值比较大小，最后决定最终更多最大值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=nums[<span class="number">0</span>];<span class="comment">//存储的是最大值</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//用来做运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">sum+=num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum=num;<span class="comment">//此时的和一定没有之前的大，所以重新开始寻找</span></span><br><span class="line">            &#125;</span><br><span class="line">            ret=ret&gt;sum?ret:sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二天-数组"><a href="#第二天-数组" class="headerlink" title="第二天 数组"></a>第二天 数组</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202111302133508.png" alt="image-20211130213312428"></p><blockquote><p>给定一个数组，判断是否有两个元素的和为指定的值，如果存在就返回两个元素的下标，没有就返回一个空的数组。</p></blockquote><p>解法一：暴力枚举</p><blockquote><p>通过两层for循环进行运算。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：非常暴力，所以时间复杂度和空间复杂度很高。</p></blockquote><p>方法二：哈希表</p><blockquote><p>首先定义一个哈希表，将数组中的每个元素放进哈希表中，并且记录其下标，然后通过指定的值减去当前的值的结果和之前已经存入哈希表中的元素进行比较，如果有相同的就返回两个元素的下标，如果没有就返回一个空数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">             hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo//img/202111302148807.png" alt="image-20211130214838743"></p><p>方法一：直接合并后排序</p><blockquote><p>将两个数组合并成一个数组，然后使用<code>Arrays.sort()</code>方法对其进行排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">nums1[m+i]=nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：双指针</p><blockquote><p>定义两个数组的头指针，然后依次判断两个数组头指针所在位置的元素的大小，保存在新的数组中，最后再将新数组中的排列好的元素放进nums1数组中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span>(p1&lt;m||p2&lt;n)&#123;</span><br><span class="line"><span class="keyword">if</span>(p1==m)&#123;</span><br><span class="line">cur=nums2[p2++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2==n)&#123;</span><br><span class="line">cur=nums1[p1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1]&gt;nums2[p2])&#123;</span><br><span class="line">cur=nums2[p2++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cur=nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[p1+p2-<span class="number">1</span>]=cur;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m+n;i++)&#123;</span><br><span class="line">             nums1[i]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：逆向双指针</p><blockquote><p>从nums1的最后向前赋值，同样定义两个指针，从后向前，判断大小依次放入nums1中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p1=m-<span class="number">1</span>, p2=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail=m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span>(p1&gt;=<span class="number">0</span>||p2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(p1==<span class="number">0</span>)&#123;</span><br><span class="line">cur=nums2[p2--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2==<span class="number">0</span>)&#123;</span><br><span class="line">cur=nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1]&gt;nums2[p2])&#123;</span><br><span class="line">cur=nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cur=nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>方法、数组的使用</title>
      <link href="/2021/11/29/%E6%96%B9%E6%B3%95%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/11/29/%E6%96%B9%E6%B3%95%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h1><h2 id="方法的基本用法"><a href="#方法的基本用法" class="headerlink" title="方法的基本用法"></a>方法的基本用法</h2><h3 id="什么是方法"><a href="#什么是方法" class="headerlink" title="什么是方法"></a>什么是方法</h3><p>方法就是一个代码片段. 类似于 C 语言中的 “函数”.</p><p>方法存在的意义:</p><blockquote><ol><li><p>是能够模块化的组织代码(当代码规模比较复杂的时候).</p></li><li><p>做到代码被重复使用, 一份代码可以在多个位置使用.</p></li><li><p>让代码更好理解更简单.</p></li><li><p>直接调用现有方法开发, 不必重复造轮子</p></li></ol></blockquote><p>代码: 计算 1! + 2! + 3! + 4! + 5!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        tmp *= j;</span><br><span class="line">   &#125;</span><br><span class="line">    sum += tmp; &#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br></pre></td></tr></table></figure><p>这个代码中使用双重循环, 比较容易写错.</p><p>接下来我们可以使用方法来优化这个代码</p><h3 id="方法定义语法"><a href="#方法定义语法" class="headerlink" title="方法定义语法"></a>方法定义语法</h3><blockquote><p><strong>基本语法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回类型 方法名 (参数类型 形参<span class="number">1</span>,参数类型 形参<span class="number">2</span>……)&#123;</span><br><span class="line">方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码示例</strong><strong>:</strong> 实现一个方法实现两个整数相加</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法的调用</span></span><br><span class="line"> <span class="keyword">int</span> ret = add(a, b);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 方法的定义</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">ret = <span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><blockquote><ol><li><p>public 和 static 两个关键字在此处具有特定含义, 我们暂时不讨论, 后面会详细介绍.</p></li><li><p>方法定义时, 参数可以没有. 每个参数要指定类型</p></li><li><p>方法定义时, 返回值也可以没有, 如果没有返回值, 则返回值类型应写成 void</p></li><li><p>方法定义时的参数称为 “形参”, 方法调用时的参数称为 “实参”.</p></li><li><p>方法的定义必须在类之中, 代码书写在调用位置的上方或者下方均可.</p></li><li><p>Java 中没有 “函数声明” 这样的概念</p></li><li><p>方法必须定义在类里。</p></li></ol></blockquote><h3 id="方法调用的执行过程"><a href="#方法调用的执行过程" class="headerlink" title="方法调用的执行过程"></a>方法调用的执行过程</h3><p><strong>基本规则</strong></p><blockquote><p>定义方法的时候, 不会执行方法的代码. 只有调用的时候才会执行.</p><p>当方法被调用的时候, 会将实参赋值给形参.</p><p>参数传递完毕后, 就会执行到方法体代码.</p><p>当方法执行完毕之后(遇到 return 语句), 就执行完毕, 回到方法调用位置继续往下执行.</p><p>一个方法可以被多次调用.</p></blockquote><p><strong>代码示例</strong> 计算两个整数相加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> System.out.println(<span class="string">&quot;第一次调用方法之前&quot;</span>);</span><br><span class="line"> <span class="keyword">int</span> ret = add(a, b);</span><br><span class="line"> System.out.println(<span class="string">&quot;第一次调用方法之后&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line"> System.out.println(<span class="string">&quot;第二次调用方法之前&quot;</span>);</span><br><span class="line"> ret = add(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;第二次调用方法之后&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;调用方法中 x = &quot;</span> + x + <span class="string">&quot; y = &quot;</span> + y);</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">一次调用方法之前</span><br><span class="line">调用方法中 x = <span class="number">10</span> y = <span class="number">20</span></span><br><span class="line">第一次调用方法之后</span><br><span class="line">ret = <span class="number">30</span></span><br><span class="line">第二次调用方法之前</span><br><span class="line">调用方法中 x = <span class="number">30</span> y = <span class="number">50</span></span><br><span class="line">第二次调用方法之后</span><br><span class="line">ret = <span class="number">80</span></span><br></pre></td></tr></table></figure><p>使用方法, 避免使用二重循环, 让代码更简单清晰</p><h3 id="实参和形参的关系"><a href="#实参和形参的关系" class="headerlink" title="实参和形参的关系"></a>实参和形参的关系</h3><p><strong>代码示例:</strong> 交换两个整型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> swap(a, b);</span><br><span class="line"> System.out.println(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot; b = &quot;</span> + b);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> tmp = x;</span><br><span class="line"> x = y;</span><br><span class="line"> y = tmp;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">a = <span class="number">10</span> b = <span class="number">20</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>原因分析</strong></p><p>刚才的代码, 没有完成数据的交换.</p><p>对于<strong>基础类型</strong>来说, 形参相当于实参的拷贝. 即 <strong>传值调用</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> x = a;</span><br><span class="line"><span class="keyword">int</span> y = b;</span><br><span class="line"><span class="keyword">int</span> tmp = x; x = y; y = tmp;</span><br></pre></td></tr></table></figure><p>可以看到, 对 x 和 y 的修改, 不影响 a 和 b.</p><p><strong>解决办法</strong>: 传引用类型参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"> swap(arr);</span><br><span class="line"> System.out.println(<span class="string">&quot;a = &quot;</span> + arr[<span class="number">0</span>] + <span class="string">&quot; b = &quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line"> arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line"> arr[<span class="number">1</span>] = tmp;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">a = <span class="number">20</span> b = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>想要理解这里，需要学习关于栈和堆的知识点，方法里的成员变量都是定义在栈里的；而new出来的对象全部在堆里，所以对象里保存的就是一个地址值，引用类型的传递就是传递地址值，所以会有上面代码解决办法的运行结果。</p><h3 id="没有返回值的方法"><a href="#没有返回值的方法" class="headerlink" title="没有返回值的方法"></a>没有返回值的方法</h3><p>方法的返回值是可选的. 有些时候可以没有的</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> print(a, b);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot; y = &quot;</span> + y);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外, 如刚才的交换两个整数的方法, 就是没有返回值的.</p><blockquote><p>除了特殊情况，一个方法有没有返回值全靠自己决定，如果觉着这个方法可以不需要返回值，就在返回值的位置写上void表示这个方法没有返回值</p></blockquote><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>有些时候我们需要用一个函数同时兼容多种参数的情况, 我们就可以使用到方法重载</p><h3 id="重载解决的问题"><a href="#重载解决的问题" class="headerlink" title="重载解决的问题"></a>重载解决的问题</h3><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">int</span> ret = add(a, b);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line"> <span class="keyword">double</span> a2 = <span class="number">10.5</span>;</span><br><span class="line"> <span class="keyword">double</span> b2 = <span class="number">20.5</span>;</span><br><span class="line"> <span class="keyword">double</span> ret2 = add(a2, b2);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret2 = &quot;</span> + ret2);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译出错</span></span><br><span class="line">Test.java:<span class="number">13</span>: 错误: 不兼容的类型: 从<span class="keyword">double</span>转换到<span class="keyword">int</span>可能会有损失</span><br><span class="line">                <span class="keyword">double</span> ret2 = add(a2, b2);</span><br><span class="line">                                  ^</span><br></pre></td></tr></table></figure><p>由于参数类型不匹配, 所以不能直接使用现有的 add 方法</p><p>那么是不是应该创建这样的代码呢?</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">int</span> ret = addInt(a, b);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line"> <span class="keyword">double</span> a2 = <span class="number">10.5</span>;</span><br><span class="line"> <span class="keyword">double</span> b2 = <span class="number">20.5</span>;</span><br><span class="line"> <span class="keyword">double</span> ret2 = addDouble(a2, b2);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret2 = &quot;</span> + ret2);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addInt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">addDouble</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用重载"><a href="#使用重载" class="headerlink" title="使用重载"></a>使用重载</h3><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">int</span> ret = add(a, b);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line"> <span class="keyword">double</span> a2 = <span class="number">10.5</span>;</span><br><span class="line"> <span class="keyword">double</span> b2 = <span class="number">20.5</span>;</span><br><span class="line"> <span class="keyword">double</span> ret2 = add(a2, b2);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret2 = &quot;</span> + ret2);</span><br><span class="line"> <span class="keyword">double</span> a3 = <span class="number">10.5</span>;</span><br><span class="line"> <span class="keyword">double</span> b3 = <span class="number">10.5</span>;</span><br><span class="line"> <span class="keyword">double</span> c3 = <span class="number">20.5</span>;</span><br><span class="line"> <span class="keyword">double</span> ret3 = add(a3, b3, c3);</span><br><span class="line"> System.out.println(<span class="string">&quot;ret3 = &quot;</span> + ret3);</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> z)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y + z;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的名字都叫 add. 但是有的 add 是计算 int 相加, 有的是 double 相加; 有的计算两个数字相加, 有的是计算三个数</p><p>字相加.</p><p>同一个方法名字, 提供不同版本的实现, 称为 <strong>方法重载</strong></p><h3 id="重载的规则"><a href="#重载的规则" class="headerlink" title="重载的规则"></a>重载的规则</h3><p>针对同一个类:</p><blockquote><p>方法名相同</p><p>方法的参数不同(参数个数或者参数类型)</p><p>方法的返回值类型不影响重载</p></blockquote><blockquote><p>当两个方法的名字相同, 参数也相同, 但是返回值不同的时候, 不构成重载</p></blockquote><h2 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h2><h3 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h3><p>一个方法在执行过程中调用自身, 就称为 “递归”.</p><p>递归相当于数学上的 “数学归纳法”, 有一个起始条件, 然后有一个递推公式</p><blockquote><p>例如, 我们求 N!</p><p>起始条件: N = 1 的时候, N! 为 1. 这个起始条件相当于递归的结束条件.</p><p>递归公式: 求 N! , 直接不好求, 可以把问题转换成 N! =&gt; N * (N-1)!</p></blockquote><p><strong>代码示例:</strong> 递归求 N 的阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = factor(n);</span><br><span class="line">    System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> n * factor(n - <span class="number">1</span>); <span class="comment">// factor 调用函数自身</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">ret = <span class="number">120</span></span><br></pre></td></tr></table></figure><h3 id="递归执行过程分析"><a href="#递归执行过程分析" class="headerlink" title="递归执行过程分析"></a><strong>递归执行过程分析</strong></h3><p>递归的程序的执行过程不太容易理解, 要想理解清楚递归, 必须先理解清楚 “方法的执行过程”, 尤其是 “方法执行结束</p><p>之后, 回到调用位置继续往下执行”.</p><p><strong>代码示例</strong>: 递归求 N 的阶乘, 加上日志版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = factor(n);</span><br><span class="line">    System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;函数开始, n = &quot;</span> + n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;函数结束, n = 1 ret = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = n * factor(n - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;函数结束, n = &quot;</span> + n + <span class="string">&quot; ret = &quot;</span> + ret);</span><br><span class="line">    <span class="keyword">return</span> ret; &#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">函数开始, n = <span class="number">5</span></span><br><span class="line">函数开始, n = <span class="number">4</span></span><br><span class="line">函数开始, n = <span class="number">3</span></span><br><span class="line">函数开始, n = <span class="number">2</span></span><br><span class="line">函数开始, n = <span class="number">1</span></span><br><span class="line">函数结束, n = <span class="number">1</span> ret = <span class="number">1</span></span><br><span class="line">函数结束, n = <span class="number">2</span> ret = <span class="number">2</span></span><br><span class="line">函数结束, n = <span class="number">3</span> ret = <span class="number">6</span></span><br><span class="line">函数结束, n = <span class="number">4</span> ret = <span class="number">24</span></span><br><span class="line">函数结束, n = <span class="number">5</span> ret = <span class="number">120</span></span><br><span class="line">ret = <span class="number">120</span></span><br></pre></td></tr></table></figure><blockquote><p>关于 “调用栈”</p><p>方法调用的时候, 会有一个 “栈” 这样的内存空间描述当前的调用关系. 称为调用栈.</p><p>每一次的方法调用就称为一个 “栈帧”, 每个栈帧中包含了这次调用的参数是哪些, 返回到哪里继续执行等信息.</p><p>后面我们借助 IDEA 很容易看到调用栈的内容</p></blockquote><h1 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h1><h2 id="数组基本用法"><a href="#数组基本用法" class="headerlink" title="数组基本用法"></a>数组基本用法</h2><h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><p>数组本质上就是让我们能 “批量” 创建相同类型的变量.</p><blockquote><p>相同类型的变量组成的集合</p><p>例如</p><p>int a1=1,a2=2,a3=3;</p><p>a1，a2，a3都是int类型的，我们就可以创建一个数组保存a1，a2，a3所储存的值</p><p>int[] array={1,2,3};</p></blockquote><p><strong>注意事项</strong>: 在 Java 中, 数组中包含的变量必须是 相同类型</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><blockquote><p>数组的创建有两种方法：</p><p>静态初始化：</p><p>数据类型[] 数组名称 = { 初始化数据 };</p><p>或表示为 数据类型[] 数组名称=new 数据类型[]{初始化数据}；</p><p><strong>//注意：静态初始化后，数组的长度确定，同时方括号不可以填值。</strong></p><p>动态初始化：</p><p>数据类型[] 数组名称=new 数据类型[数组的长度]；</p></blockquote><p> 代码示范：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[ ] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[ ] array=<span class="keyword">new</span> <span class="keyword">int</span>[ ]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//必须在声明的时候让同时初始化</span></span><br><span class="line">====================</span><br><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//创建一个长度为3的int数组</span></span><br><span class="line"><span class="comment">//上明是声明，初始化如下</span></span><br><span class="line">array[<span class="number">0</span>]=<span class="number">1</span>; array[<span class="number">1</span>]=<span class="number">2</span>; array[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//数组的下标从0开始</span></span><br></pre></td></tr></table></figure><p> <strong>注意事项</strong>: 静态初始化的时候, 数组元素个数和初始化数据的格式是一致的.</p><h3 id="数组的使用-1"><a href="#数组的使用-1" class="headerlink" title="数组的使用"></a>数组的使用</h3><p><strong>代码示例</strong>: 获取长度 &amp; 访问元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 获取数组长度</span></span><br><span class="line">System.out.println(<span class="string">&quot;length: &quot;</span> + arr.length); <span class="comment">// 执行结果: 3</span></span><br><span class="line"><span class="comment">// 访问数组中的元素</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>]); <span class="comment">// 执行结果: 2</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 执行结果: 1</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">100</span>; System.out.println(arr[<span class="number">2</span>]); <span class="comment">// 执行结果: 100</span></span><br></pre></td></tr></table></figure><p> <strong>注意事项</strong></p><blockquote><ol><li><p>使用 arr.length 能够获取到数组的长度. . 这个操作为成员访问操作符. 后面在面向对象中会经常用到.</p></li><li><p>使用 [ ] 按下标取数组元素. 需要注意, 下标从 0 开始计数</p></li><li><p>使用 [ ] 操作既能读取数据, 也能修改数据.</p></li><li><p>下标访问操作不能超出有效范围 [0, length - 1] , 如果超出有效范围, 会出现下标越界异常</p></li></ol></blockquote><p> <strong>代码示例</strong>: 遍历数组</p><p>所谓 “遍历” 是指将数组中的所有元素都访问一遍, 不重不漏. 通常需要搭配循环语句.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p> <strong>代码示例</strong>: 使用 for-each 遍历数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>for-each 是 for 循环的另外一种使用方式. 能够更方便的完成对数组的遍历. 可以避免循环条件和更新语句写错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用<span class="keyword">for</span>-each循环数组：</span><br><span class="line">基本结构:</span><br><span class="line"><span class="keyword">for</span>(数据类型 数据名: 数组名)&#123;</span><br><span class="line">     执行语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组作为方法的参数"><a href="#数组作为方法的参数" class="headerlink" title="数组作为方法的参数"></a>数组作为方法的参数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p> <strong>代码示例</strong>: 打印数组内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">printArray(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : a) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p> <strong>在这个代码中</strong></p><blockquote><p>int[] a 是函数的形参, int[] arr 是函数实参.</p><p>如果需要获取到数组长度, 同样可以使用 a.length</p></blockquote><h3 id="理解引用类型"><a href="#理解引用类型" class="headerlink" title="理解引用类型"></a>理解引用类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p> 通过运行发现，array存储的是一个地址，”[“表示是一个一维数组，“I”则表示int类型，@后面的就是这个数组的具体位置值。通过这个例子可知，数组是引用数据类型，其存储的是一个地址。</p></blockquote><p> <strong>代码示例</strong> 参数传内置类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">func(num);</span><br><span class="line">System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果</p><p> x = 10</p><p> num = 0</p></blockquote><p> func方法内关于x的值得修改不会影响主方法中num的值，这是<strong>值传递</strong>。值传递就是num把自己的之传给func方法做形参，但是方法中x的值的改变并不会对原本的num有任何影响。</p><p> <strong>代码示例</strong> 参数传数组类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">func(arr);</span><br><span class="line">System.out.println(<span class="string">&quot;arr[0] = &quot;</span> + arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a[0] = &quot;</span> + a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果</p><p> a[0] = 10</p><p> arr[0] = 10</p></blockquote><p> 我们发现, 在函数内部修改数组内容, 函数外部也发生改变.</p><p>此时数组名 arr 是一个 “引用” . 当传参的时候, 是按照引用传参.</p><p> 这里我们要先从内存开始说起.</p><blockquote><p>如何理解内存?</p><p>内存就是指我们熟悉的 “内存”. 内存可以直观的理解成一个宿舍楼. 有一个长长的大走廊, 上面有很多房间. 每个房间的大小是 1 Byte (如果计算机有 8G 内存, 则相当于有 80亿 个这样的房间). 每个房间上面又有一个门牌号, 这个门牌号就称为 地址</p></blockquote><p> 那么啥又是引用?</p><blockquote><p>什么是引用?</p><p>引用相当于一个 “别名”, 也可以理解成一个指针. 创建一个引用只是相当于创建了一个很小的变量, 这个变量保存了一个整数, 这个整数表示内存中的一个地址.</p></blockquote><p>针对 int[] arr = new int[]{1, 2, 3} 这样的代码, 内存布局如图:</p><p>a) 当我们创建 new int[]{1, 2, 3} 的时候, 相当于创建了一块内存空间保存三个 int</p><p>b) 接下来执行 int[] arr = new int[]{1, 2, 3} 相当于又创建了一个 int[] 变量, 这个变量是一个引用类型, 里 面只保存了一个整数(数组的起始内存地址)</p><p><img src="https://img-blog.csdnimg.cn/563bb7dfaa544f1bab20fde6717a8d5f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeXV1eWlu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="image"></p><p> c) 接下来我们进行传参相当于 int[] a = arr , 内存布局如图</p><p><img src="https://i.loli.net/2021/11/29/k6XSC8HIzUED1Af.png" alt="image"></p><p> d) 接下来我们修改 a[0] , 此时是根据 0x100 这样的地址找到对应的内存位置, 将值改成 100</p><p><img src="https://img-blog.csdnimg.cn/047b8f5a02f447acac6df51e4a70fde6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeXV1eWlu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 此时已经将 0x100 地址的数据改成了 100 . 那么根据实参 arr 来获取数组内容 arr[0] , 本质上也是获取 0x100 地址上的数据, 也是 100.</p><p><strong>总结</strong>: 所谓的 “引用” 本质上只是存了一个地址. Java 将数组设定成引用类型, 这样的话后续进行数组参数传参, 其实 只是将数组的地址传入到函数形参中. 这样可以避免对整个数组的拷贝(数组可能比较长, 那么拷贝开销就会很大).</p><h3 id="认识null"><a href="#认识null" class="headerlink" title="认识null"></a>认识null</h3><p>null 在 Java 中表示 “空引用” , 也就是一个无效的引用</p><blockquote><p>int[] arr = null;</p><p>​    System.out.println(arr[0]);</p><p>// 执行结果 Exception in thread “main” java.lang.NullPointerException</p><p>​        atTest.main(Test.java:6)</p></blockquote><p> null 的作用类似于 C 语言中的 NULL (空指针), 都是表示一个无效的内存位置. 因此不能对这个内存进行任何读写操 作. 一旦尝试读写, 就会抛出 NullPointerException.</p><blockquote><p>注意: Java 中并没有约定 null 和 0 号地址的内存有任何关联.</p></blockquote><h3 id="初识Jvm内存区域划分"><a href="#初识Jvm内存区域划分" class="headerlink" title="初识Jvm内存区域划分"></a>初识Jvm内存区域划分</h3><blockquote><p>一个宿舍楼会划分成几个不同的区域: 大一学生, 大二学生… 计算机专业学生, 通信专业学生….</p><p>内存也是类似, 这个大走廊被分成很多部分, 每个区域存放不同的数据.</p></blockquote><p>JVM 的内存被划分成了几个区域, 如图所示</p><p><img src="https://img-blog.csdnimg.cn/f05e9a869ffa4e888f08fc92bc046bc6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeXV1eWlu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p> 程序计数器 (PC Register): 只是一个很小的空间, 保存下一条执行的指令的地址.</p><p>虚拟机栈(JVM Stack): 重点是存储局部变量表(当然也有其他信息). 我们刚才创建的 int[] arr 这样的存储地 址的引用就是在这里保存.</p><p>本地方法栈(Native Method Stack): 本地方法栈与虚拟机栈的作用类似. 只不过保存的内容是Native方法的局 部变量. 在有些版本的 JVM 实现中(例如HotSpot), 本地方法栈和虚拟机栈是一起的.</p><p>堆(Heap): JVM所管理的最大内存区域. 使用 new 创建的对象都是在堆上保存 (例如前面的 new int[]{1, 2, 3} )</p><p>方法区(Method Area): 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数 据. 方法编译出的的字节码就是保存在这个区域.</p><p>运行时常量池(Runtime Constant Pool): 是方法区的一部分, 存放字面量(字符串常量)与符号引用. (注意 从 JDK 1.7 开始, 运行时常量池在堆上)</p><blockquote><p> Native 方法:</p><p> JVM 是一个基于 C++ 实现的程序. 在 Java 程序执行过程中, 本质上也需要调用 C++ 提供的一些函数进行和操 作系统底层进行一些交互. 因此在 Java 开发中也会调用到一些 C++ 实现的函数. 这里的 Native 方法就是指这些 C++ 实现的, 再由 Java 来调用的函数.</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/067eab36ca7b4c9781b13d7b148a8f66.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeXV1eWlu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 局部变量和引用保存在栈上, new 出的对象保存在堆上.</p><p>堆的空间非常大, 栈的空间比较小.</p><p>堆是整个 JVM 共享一个, 而栈每个线程具有一份(一个 Java 程序中可能存在多个栈) </p><h2 id="数组作为方法的返回值"><a href="#数组作为方法的返回值" class="headerlink" title="数组作为方法的返回值"></a>数组作为方法的返回值</h2><p><strong>代码示例</strong>: 写一个方法, 将数组中的每个元素都 * 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">transform(arr);</span><br><span class="line">printArray(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = arr[i] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个代码固然可行, 但是破坏了原有数组. 有时候我们不希望破坏原数组, 就需要在方法内部创建一个新的数组, 并由 方法返回出来.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] output = transform(arr);</span><br><span class="line">printArray(output);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] transform(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">ret[i] = arr[i] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话就不会破坏原有数组了.</p><p>另外由于数组是引用类型, 返回的时候只是将这个数组的首地址返回给函数调用者, 没有拷贝数组内容, 从而比较高效</p><h2 id="数组练习"><a href="#数组练习" class="headerlink" title="数组练习"></a>数组练习</h2><h3 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h3><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">String newArr = Arrays.toString(arr);</span><br><span class="line">System.out.println(newArr);</span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果</p><p> [1, 2, 3, 4, 5, 6]</p></blockquote><p> 使用这个方法后续打印数组就更方便一些.</p><p>Java 中提供了 <strong>java.util.Arrays</strong> 包, 其中包含了一些操作数组的常用方法.</p><blockquote><p>什么是包?</p><p>例如做一碗油泼面, 需要先和面, 擀面, 扯出面条, 再烧水, 下锅煮熟, 放调料, 泼油.</p><p>但是其中的 “和面, 擀面, 扯出面条” 环节难度比较大, 不是所有人都能很容易做好. 于是超市就提供了一些直接 已经扯好的面条, 可以直接买回来下锅煮. 从而降低了做油泼面的难度, 也提高了制作效率.</p><p>程序开发也不是从零开始, 而是要站在巨人的肩膀上.</p><p>像我们很多程序写的过程中不必把所有的细节都自己实现, 已经有大量的标准库(JDK提供好的代码)和海量的 第三方库(其他机构组织提供的代码)供我们直接使用. 这些代码就放在一个一个的 “包” 之中. 所谓的包就相当 于卖面条的超市. 只不过, 超市的面条只有寥寥几种, 而我们可以使用的 “包” , 有成千上万</p></blockquote><p> 我们实现一个自己版本的数组转字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">String ret = <span class="string">&quot;[&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">// 借助 String += 进行拼接字符串</span></span><br><span class="line">ret += arr[i];</span><br><span class="line"><span class="comment">// 除了最后一个元素之外, 其他元素后面都要加上 &quot;, &quot;</span></span><br><span class="line"><span class="keyword">if</span> (i != arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">ret += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ret += <span class="string">&quot;]&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p> 代码示范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(arr, arr.length);</span><br><span class="line">System.out.println(<span class="string">&quot;newArr: &quot;</span> + Arrays.toString(newArr));</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;arr: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">System.out.println(<span class="string">&quot;newArr: &quot;</span> + Arrays.toString(newArr));</span><br><span class="line"><span class="comment">// 拷贝某个范围.</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOfRange(arr, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;newArr2: &quot;</span> + Arrays.toString(newArr2));</span><br></pre></td></tr></table></figure><p> 注意事项:</p><p>相比于 newArr = arr 这样的赋值, copyOf 是将数组进行了 深拷贝, 即又创建了一个数组对象, 拷贝原有 数组中的所有元素到新数组中. 因此, 修改原数组, 不会影响到新数组.</p><p> 实现自己版本的拷贝数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">ret[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找数组中的最大元素"><a href="#找数组中的最大元素" class="headerlink" title="找数组中的最大元素"></a>找数组中的最大元素</h3><p> 给定一个整型数组, 找到其中的最大元素 (找最小元素同理)</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(max(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">max = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果 6</p></blockquote><p> 类似于 “打擂台” 这样的过程. 其中 max 变量作为 擂台, 比擂台上的元素大, 就替换上去, 否则就下一个对手</p><h3 id="求数组中元素的平均值"><a href="#求数组中元素的平均值" class="headerlink" title="求数组中元素的平均值"></a>求数组中元素的平均值</h3><p> 给定一个整型数组, 求平均值</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(avg(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">avg</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;</span><br><span class="line">sum += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>)sum / (<span class="keyword">double</span>)arr.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果 3.5</p></blockquote><p> 注意事项: 结果要用 double 来表示</p><h3 id="查找数组中的指定元素（顺序查找）"><a href="#查找数组中的指定元素（顺序查找）" class="headerlink" title="查找数组中的指定元素（顺序查找）"></a>查找数组中的指定元素（顺序查找）</h3><p> 给定一个数组, 再给定一个元素, 找出该元素在数组中的位置.</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(find(arr, <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> toFind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] == toFind) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 表示没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>// 执行结果 3 </p></blockquote><h3 id="查找数组中的指定元素（二分查找）"><a href="#查找数组中的指定元素（二分查找）" class="headerlink" title="查找数组中的指定元素（二分查找）"></a>查找数组中的指定元素（二分查找）</h3><p> 针对有序数组, 可以使用更高效的二分查找</p><blockquote><p> 啥叫有序数组?</p><p> 有序分为 “升序” 和 “降序” 如 1 2 3 4 ,</p><p> 依次递增即为升序. 如 4 3 2 1 ,</p><p> 依次递减即为降序.</p></blockquote><p> 以升序数组为例, 二分查找的思路是先取中间位置的元素, 看要找的值比中间元素大还是小. 如果小, 就去左边找; 否 则就去右边找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(binarySearch(arr, <span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> toFind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (toFind &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="comment">// 去左侧区间找</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFind &gt; arr[mid]) &#123;</span><br><span class="line"><span class="comment">// 去右侧区间找</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 相等, 说明找到了</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 循环结束, 说明没找到</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果 5</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 创建一个成员变量, 记录二分查找循环次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = makeBigArray();</span><br><span class="line"><span class="keyword">int</span> ret = binarySearch(arr, <span class="number">9999</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;ret = &quot;</span> + ret + <span class="string">&quot; count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] makeBigArray() &#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> toFind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">count++; <span class="comment">// 使用一个变量记录循环执行次数</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (toFind &lt; arr[mid]) &#123;</span><br><span class="line"><span class="comment">// 去左侧区间找</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (toFind &gt; arr[mid]) &#123;</span><br><span class="line"><span class="comment">// 去右侧区间找</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 相等, 说明找到了</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果 ret = 9999 count = 14</p></blockquote><p>可以看到, 针对一个长度为 10000 个元素的数组查找, 二分查找只需要循环 14 次就能完成查找. 随着数组元素个数 越多, 二分的优势就越大.</p><h3 id="检查数组的有序性"><a href="#检查数组的有序性" class="headerlink" title="检查数组的有序性"></a>检查数组的有序性</h3><p> 给定一个整型数组, 判断是否该数组是有序的(升序)</p><p>代码示范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">System.out.println(isSorted(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组排序-冒泡排序"><a href="#数组排序-冒泡排序" class="headerlink" title="数组排序(冒泡排序)"></a>数组排序(冒泡排序)</h3><p> 给定一个数组, 让数组升序 (降序) 排序.</p><p><strong>算法思路</strong> 每次尝试找到当前待排序区间中最小(或最大)的元素, 放到数组最前面(或最后面).</p><p>代码示例    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">bubbleSort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// [0, bound) 构成了一个前闭后开区间, 表示已排序区间</span></span><br><span class="line"><span class="comment">// [bound, length) 构成了一个前闭后开区间, 表示待排序区间</span></span><br><span class="line"><span class="comment">// 每循环一次, 就找到一个合适大小的元素, 已排序区间就增大1.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> bound = <span class="number">0</span>; bound &lt; arr.length; bound++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> cur = arr.length - <span class="number">1</span>; cur &gt; bound; cur--) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[cur - <span class="number">1</span>] &gt; arr[cur]) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[cur - <span class="number">1</span>];</span><br><span class="line">arr[cur - <span class="number">1</span>] = arr[cur];</span><br><span class="line">arr[cur] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end for</span></span><br><span class="line">&#125; <span class="comment">// end bubbleSort</span></span><br></pre></td></tr></table></figure><blockquote><p> // 执行结果 [2, 5, 7, 9]</p></blockquote><p> 冒泡排序性能较低. Java 中内置了更高效的排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 Arrays.sort 的具体实现算法, 我们在后面的排序算法课上再详细介绍. 到时候我们会介绍很多种常见排序算法. </p><h3 id="数组逆序"><a href="#数组逆序" class="headerlink" title="数组逆序"></a>数组逆序</h3><p> 给定一个数组, 将里面的元素逆序排列.</p><p><strong>思路</strong> 设定两个下标, 分别指向第一个元素和最后一个元素. 交换两个位置的元素. 然后让前一个下标自增, 后一个下标自减, 循环继续即可.</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">reverse(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">arr[right] = tmp;</span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组数字排列"><a href="#数组数字排列" class="headerlink" title="数组数字排列"></a>数组数字排列</h3><p> 给定一个整型数组, 将所有的偶数放在前半部分, 将所有的奇数放在数组后半部分</p><blockquote><p>例如</p><p>{1, 2, 3, 4}</p><p>调整后得到 {4, 2, 3, 1}</p></blockquote><p><strong>基本思路</strong> 设定两个下标分别指向第一个元素和最后一个元素. 用前一个下标从左往右找到第一个奇数, 用后一个下标从右往左找到第一个偶数, 然后交换两个位置的元素. 依次循环即可.</p><p>代码示范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">transform(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">// 该循环结束, left 就指向了一个奇数</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该循环结束, right 就指向了一个偶数</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换两个位置的元素</span></span><br><span class="line"><span class="keyword">int</span> tmp = arr[left];</span><br><span class="line">arr[left] = arr[right];</span><br><span class="line">arr[right] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组本质上也就是一维数组, 只不过每个元素又是一个一维数组.</p><p><strong>基本语法</strong></p><blockquote><p>数据类型[][] 数组名称 = new 数据类型 [行数][列数] { 初始化数据 };</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; arr.length; row++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; arr[row].length; col++) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t&quot;</span>, arr[row][col]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p> 二维数组的用法和一维数组并没有明显差别, 因此我们不再赘述. 同理, 还存在 “三维数组”, “四维数组” 等更复杂的数组, 只不过出现频率都很低</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础程序设计</title>
      <link href="/2021/11/28/Java%E5%9F%BA%E7%A1%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/11/28/Java%E5%9F%BA%E7%A1%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构和运算符"><a href="#数据结构和运算符" class="headerlink" title="数据结构和运算符"></a>数据结构和运算符</h1><h2 id="1-标识符"><a href="#1-标识符" class="headerlink" title="1 标识符"></a>1 标识符</h2><p><strong>标识符的定义：Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符</strong></p><p>​        自己命名的都可以叫做标识符</p><p><strong>标识符的命名规范</strong>：</p><blockquote><p><strong>由26个英文字母大小写，0-9 ，_或$组成</strong></p><p><strong>数字不可以开头。</strong></p><p><strong>不可以使用关键字和保留字，但能包含关键字和保留字。</strong></p><p><strong>Java中严格区分大小写，长度无限制。</strong></p><p><strong>标识符不能包含空格。</strong></p></blockquote><p><strong>标识符的命名规则</strong>：</p><blockquote><p><strong>包名</strong>：多单词组成时所有字母都小写：xxxyyyzzz</p><p><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：XxxYyyZzz</p><p><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</p><p><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</p></blockquote><blockquote><blockquote><p>注意：见名知意</p></blockquote></blockquote><h2 id="2-变量和类型"><a href="#2-变量和类型" class="headerlink" title="2 变量和类型"></a>2 变量和类型</h2><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><strong>变量</strong>：指的是程序运行时可变的量. 相当于开辟一块内存空间来保存一些数据.</p><p><strong>类型</strong>则是对变量的种类进行了划分, 不同的类型的变量具有不同的特性</p><p>所有的变量<strong>必须先声明，再使用</strong></p><p><strong>作用域</strong>：被定义的花括号内</p><p>变量的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型 变量名=初始化值;</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;<span class="comment">//声明并初始化</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="keyword">int</span> a;<span class="comment">//声明</span></span><br><span class="line">a=<span class="number">10</span>;<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><p>变量按照数据类型可分为 <strong>基本数据类型</strong>和 <strong>引用类型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211118230016991.png" alt="image-20211118230016991"></p><p>变量的**分类-**按声明的位置的不同</p><blockquote><p><strong>在方法体外，类体内声明的变量称为成员变量。</strong> </p><p><strong>在方法体内部声明的变量称为局部变量</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211118231017604.png" alt="image-20211118231017604"></p><p><strong>二者在初始化值方面的异同:</strong></p><blockquote><p><strong>同：</strong>都有生命周期 </p><p><strong>异：局部变量</strong>除形参外，需显式初始化。</p></blockquote><hr><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p><strong>常量：</strong></p><ol><li>字面值常量</li><li>final修饰的常量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="2-1基本数据类型"><a href="#2-1基本数据类型" class="headerlink" title="2.1基本数据类型"></a>2.1基本数据类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>byte(1个字节)、short(2个字节)、int(4个字节)、long(8个字节)</p><blockquote><p>Java的整型默认为int类型，long类型需要在最后加”l”或者“L”</p></blockquote><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>float(4个字节)、double(8个字节)</p><blockquote><p>Java的整型默认为double类型，float类型需要在最后加”f”或者“F”</p></blockquote><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ol><li><p>Java 中使用 单引号 + 单个字母 的形式表示字符字面值.</p></li><li><p>计算机中的字符本质上是一个整数. 在 C 语言中使用 ASCII 表示字符, 而 Java 中使用 Unicode 表示字符. 因此一</p></li></ol><p>个字符占用两个字节, 表示的字符种类更多, 包括中文.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch=<span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p><strong>boolean 类型用来判断逻辑条件，一般用于程序流程控制</strong></p><p>boolean的数据只有两个：<strong>true、false</strong></p><h4 id="String类型（引用类型）"><a href="#String类型（引用类型）" class="headerlink" title="String类型（引用类型）"></a>String类型（引用类型）</h4><p><strong>String不是基本数据类型，属于引用数据类型</strong></p><p> <strong>使用方式与基本数据类型一致</strong>。例如：<code>String str = “abcd”;</code></p><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str = str + “xyz” ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">str = str + n;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>转义字符</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\‘</td><td>单引号</td></tr><tr><td>\‘</td><td>双引号</td></tr><tr><td>\\</td><td>反斜杠</td></tr></tbody></table><h3 id="2-2基本数据类型变量间转换"><a href="#2-2基本数据类型变量间转换" class="headerlink" title="2.2基本数据类型变量间转换"></a>2.2基本数据类型变量间转换</h3><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p><strong>容量小的类型自动转换为容量大的数据类型。</strong></p><p>数据类型按容量大小排序为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>&lt; <span class="keyword">short</span> 、 <span class="keyword">char</span> &lt;<span class="keyword">int</span> &lt;<span class="keyword">long</span>&lt; <span class="keyword">float</span> &lt; <span class="keyword">double</span></span><br></pre></td></tr></table></figure><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p><strong>容量大的类型自动转换为容量小的数据类型。</strong></p><p>**使用时要加上强制转换符：()**，</p><p>注意：<strong>但可能造成精度降低或溢出,格外要注意。</strong></p><h3 id="2-3int类型与String间转换"><a href="#2-3int类型与String间转换" class="headerlink" title="2.3int类型与String间转换"></a>2.3int类型与String间转换</h3><p><strong>int</strong> <strong>转成</strong> <strong>String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="comment">// 方法1 </span></span><br><span class="line">String str1 = num + <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="comment">// 方法2 </span></span><br><span class="line">String str2 = String.valueOf(num); </span><br></pre></td></tr></table></figure><p><strong>String 转成 int</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;100&quot;</span>; </span><br><span class="line"><span class="keyword">int</span> num = Integer.parseInt(str);</span><br></pre></td></tr></table></figure><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3 运算符"></a>3 运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><blockquote><p>基本的四则运算 ：+、-、*、/</p></blockquote><p>和数学的加减乘除差不多，关于除法，如果是两个整型，结果是一个整型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">87</span>;</span><br><span class="line"><span class="keyword">int</span> k=j/<span class="number">5</span>;</span><br><span class="line"><span class="comment">//最后的结果是 k=13</span></span><br></pre></td></tr></table></figure><blockquote><p>“+”:如果是两个基本数据类型，他表示加法，如果有一个是字符串类型，这里的“+”表示为连接符</p></blockquote><p>l例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">123</span>;</span><br><span class="line">String str2=str+i;</span><br><span class="line"><span class="comment">//结果str2=“abc123”;</span></span><br></pre></td></tr></table></figure><blockquote><p>取模：%</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">19</span>%<span class="number">5</span>;</span><br><span class="line"><span class="comment">//结果i=4;</span></span><br></pre></td></tr></table></figure><blockquote><p>自增（自减）：++、–</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前自增 ++i先自加，再运算</span></span><br><span class="line">a=<span class="number">2</span>;b=++a;</span><br><span class="line">结果：a=<span class="number">3</span>,b=<span class="number">3</span></span><br><span class="line"><span class="comment">//后自增 i++先运算，再自加</span></span><br><span class="line">a=<span class="number">2</span>;b=a++;</span><br><span class="line">结果：a=<span class="number">2</span>,b=<span class="number">3</span></span><br><span class="line"><span class="comment">//前自减 --i先自减，再运算</span></span><br><span class="line">a=<span class="number">2</span>;b=--a;</span><br><span class="line">结果：a=<span class="number">1</span>,b=<span class="number">1</span></span><br><span class="line"><span class="comment">//后自减 i--先运算，再自减</span></span><br><span class="line">a=<span class="number">2</span>;b=a--;</span><br><span class="line">结果：a=<span class="number">2</span>,b=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">i++;<span class="comment">//最后的i=11;</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><blockquote><p>增量赋值运算符 +=     -=     *=     /=     %=</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示范：</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">a+=<span class="number">2</span>;<span class="comment">//相当于a=a+2;12</span></span><br><span class="line">a-=<span class="number">2</span>;<span class="comment">//相当于a=a-2;8</span></span><br><span class="line">a*=<span class="number">2</span>;<span class="comment">//相当于a=a*2;20</span></span><br><span class="line">a/=<span class="number">2</span>;<span class="comment">//想当于a=a/2;5</span></span><br><span class="line">a%=<span class="number">2</span>;<span class="comment">//相当于a=a%2;0</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><blockquote><p>关系运算符主要有6种：</p><p>==    !=    &gt;    &lt;    &gt;=    &lt;=</p><p>所有的关系运算符的表达式的返回值都是boolean类型</p></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><blockquote><p>逻辑与—&amp;    逻辑或—|    逻辑非—!</p><p>短路与—&amp;&amp;    短路或—||    逻辑异或—^</p></blockquote><table><thead><tr><th>a</th><th>b</th><th>a&amp;b</th><th>a&amp;&amp;b</th><th>a|b</th><th>a||b</th><th>!a</th><th>a^b</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td><td>true</td><td>true</td><td>true</td><td>true</td></tr><tr><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td><td>false</td></tr></tbody></table><blockquote><p>&amp;和&amp;&amp;的区别：</p><p>&amp;：左边无论真假，右边都会进行运算</p><p>&amp;&amp;：左边为真，右边参与运算；左边为假，整个运算的结果直接为假</p></blockquote><blockquote><p>|和||的区别：</p><p>|：左边无论真假，右边都会进行运算</p><p>||：左边为假，右边参与运算；左边为真，整个运算的结果直接为真</p></blockquote><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>运算的是二进制数</p><blockquote><p>​    &amp;    |    ~    ^</p></blockquote><p><strong>按位与</strong> <strong>&amp;</strong>: 如果两个二进制位都是 1, 则结果为 1, 否则结果为 0</p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211119131323950.png" alt="image-20211119131323950"></p><p><strong>按位或 |: 如果两个二进制位都是 0, 则结果为 0, 否则结果为 1.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211119131336327.png" alt="image-20211119131336327"></p><p><strong>按位取反 ~: 如果该位为 0 则转为 1, 如果该位为 1 则转为 0</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211119131343293.png" alt="image-20211119131343293"><br><strong>按位异或 ^: 如果两个数字的二进制位相同, 则结果为 0, 相异则结果为 1.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/fishyin/picodemo/img/image-20211119131355454.png" alt="image-20211119131355454"></p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><blockquote><p>移位运算符有三个:</p><p>&lt;&lt;    &gt;&gt;    &gt;&gt;&gt;</p></blockquote><p><strong>左移 &lt;&lt;: 最左侧位不要了, 最右侧补 0.</strong></p><p><strong>右移 &gt;&gt;: 最右侧位不要了, 最左侧补符号位(正数补0, 负数补1)</strong></p><p><strong>无符号右移 &gt;&gt;&gt;: 最右侧位不要了, 最左侧补 0.</strong></p><p><strong>注意:</strong></p><ol><li><p>左移 1 位, 相当于原数字 * 2. 左移 N 位, 相当于原数字 * 2 的N次方.</p></li><li><p>右移 1 位, 相当于原数字 / 2. 右移 N 位, 相当于原数字 / 2 的N次方.</p></li><li><p>由于计算机计算移位效率高于计算乘除, 当某个代码正好乘除 2 的N次方的时候可以用移位运算代替.</p></li><li><p>移动负数位或者移位位数过大都没有意义</p></li></ol><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p><strong>条件运算符只有一个:</strong> </p><p><strong>表达式1 ? 表达式2 : 表达式3</strong></p><p>当 表达式1 的值为 true 时, 整个表达式的值为 表达式2 的值; 当 表达式1 的值为 false 时, 整个表达式的值为 表达式 3 的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max=a&gt;b?a:b;        <span class="comment">//结果为 max=32</span></span><br></pre></td></tr></table></figure><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4 注释"></a>4 注释</h2><p><strong>注释是为了让代码更容易被读懂而附加的描述信息. 不参与编译运行, 但是却非常重要. 时刻牢记! 代码写出来是为了给人看的, 更是为了给三个月后的你自己看的.</strong></p><h3 id="4-1-基本规则"><a href="#4-1-基本规则" class="headerlink" title="4.1 基本规则"></a>4.1 基本规则</h3><p>Java中的注释主要分为以下三种</p><p><strong>单行注释：// 注释内容（用的最多）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);    </span><br><span class="line">        <span class="comment">//这是一个单行注释，运行的时候不会显示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多行注释：/* 注释内容*/（不推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这是一个多行注释，运行的时候不会显示</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文档注释： /</strong> 文档注释 <em>/（常见于方法和类之上描述方法和类的作用)，可用来自动生成文档</em>*</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这是一个多行注释，运行的时候不会显示</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-注释规范"><a href="#4-2-注释规范" class="headerlink" title="4.2 注释规范"></a>4.2 注释规范</h3><ol><li><p>内容准确: 注释内容要和代码一致, 匹配, 并在代码修改时及时更新.</p></li><li><p>篇幅合理: 注释既不应该太精简, 也不应该长篇大论.</p></li><li><p>使用中文: 一般中国公司都要求使用中文写注释, 外企另当别论.</p></li><li><p>积极向上: 注释中不要包含负能量(例如 领导 SB 等).</p></li></ol><h2 id="5-关键字"><a href="#5-关键字" class="headerlink" title="5 关键字"></a>5 关键字</h2><p><strong>关键字是被Java定义的具有特殊含义，具有专门用途的字符串</strong></p><table><thead><tr><th align="center">用来定义访问修饰符的关键字</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="center">private</td><td>protected</td><td>public</td><td></td><td></td></tr><tr><td align="center"><strong>用来定义类，方法，变量修饰符的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">abstract</td><td>final</td><td>static</td><td>synchronized</td><td></td></tr><tr><td align="center"><strong>用来定义类和类之间关系的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">extends</td><td>implements</td><td></td><td></td><td></td></tr><tr><td align="center"><strong>用于定义建立实例及引用实例，判断实例的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">new</td><td>this</td><td>super</td><td>instanceof</td><td></td></tr><tr><td align="center"><strong>用于异常处理的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">try</td><td>catch</td><td>finally</td><td>throw</td><td>throws</td></tr><tr><td align="center"><strong>用于包的关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">package</td><td>import</td><td></td><td></td><td></td></tr><tr><td align="center"><strong>其他修饰符关键字</strong></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">native</td><td>strictfp</td><td>transient</td><td>volatile</td><td>assert</td></tr></tbody></table><p><strong>保留字：</strong>现有Java版本尚未使用，但以后版本可能会作为关键字使用。</p><table><thead><tr><th>goto</th><th>const</th></tr></thead></table><h1 id="程序逻辑控制"><a href="#程序逻辑控制" class="headerlink" title="程序逻辑控制"></a>程序逻辑控制</h1><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p><strong>程序从上到下逐行地执行，中间没有任何判断和跳转。</strong></p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>if语句有三种形式，单分支形式，双分支形式和多分支形式</p><h5 id="2-1-1单分支形式"><a href="#2-1-1单分支形式" class="headerlink" title="2.1.1单分支形式"></a>2.1.1单分支形式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">      条件满足时执行代码;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例: 判定一个人是不是成年人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age=<span class="number">19</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(age&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;年龄&quot;</span>+age+<span class="string">&quot;已经成年了&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2双分支形式"><a href="#2-1-2双分支形式" class="headerlink" title="2.1.2双分支形式"></a>2.1.2双分支形式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123; </span><br><span class="line">     <span class="comment">//条件满足时执行代码   </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123; </span><br><span class="line">      <span class="comment">//条件不满足时执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码实例：判定一个数字是奇数还是偶数</p><pre><code>int num = 10;if (num % 2 == 0) &#123;      System.out.println(&quot;num 是偶数&quot;);&#125; else &#123;         System.out.println(&quot;num 是奇数&quot;);&#125;</code></pre><h5 id="2-1-3多分支形式"><a href="#2-1-3多分支形式" class="headerlink" title="2.1.3多分支形式"></a>2.1.3多分支形式</h5><pre><code>if(布尔表达式)&#123;    //条件满足时执行代码&#125;else if(布尔表达式)&#123;        //条件满足时执行代码&#125;else&#123;              //条件都不满足时执行代码&#125;</code></pre><p> 代码实例：判定一个数字是正数还是负数</p><pre><code>int num = 10;if (num &gt; 0) &#123;         System.out.println(&quot;num 是正数&quot;);&#125; else if (num &lt; 0) &#123;      System.out.println(&quot;num 是负数&quot;);&#125; else &#123;      System.out.println(&quot;num 是 0&quot;);&#125;</code></pre><p><strong>分支结构：if-else使用说明</strong></p><ol><li>  条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li><li>  语句块只有一条执行语句时，一对{}可以省略，但建议保留</li><li>  if-else语句结构，根据需要可以嵌套使用</li><li>  当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略</li><li>  当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓</li><li>  当多个条件是“包含”关系时，“小上大下 / 子上父下”</li></ol><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>基本语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(整数|枚举|字符|字符串)&#123;</span><br><span class="line"> <span class="keyword">case</span> 内容<span class="number">1</span> : &#123;</span><br><span class="line"> 内容满足时执行语句;</span><br><span class="line"> [<span class="keyword">break</span>;]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">case</span> 内容<span class="number">2</span> : &#123;</span><br><span class="line"> 内容满足时执行语句;</span><br><span class="line"> [<span class="keyword">break</span>;]</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">default</span>:&#123;</span><br><span class="line"> 内容都不满足时执行语句;</span><br><span class="line"> [<span class="keyword">break</span>;]</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch(表达式)中表达式的值<strong>必须</strong>是下述几种类型之一：**byte、short、char、int、枚举(jdk 5.0)、String (jdk 7.0)**； </p><ol><li>case子句中的值必须是<strong>常量</strong>，不能是变量名或不确定的表达式值；</li><li>同一个switch语句，所有case子句中的常量值互不相同；</li><li>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到switch结尾</li><li>default子句是<strong>可任选的</strong>。同时，位置也是灵活的。当没有匹配的case时，执行default</li></ol><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>基本语法格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">        循环语句;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环条件为 true, 则执行循环语句; 否则结束循环.</span></span><br></pre></td></tr></table></figure><p>代码示例1: 打印 1 - 10 的数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">10</span>) &#123; </span><br><span class="line">             System.out.println(num); </span><br><span class="line">             num++; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>注意事项</strong></p><ol><li><p>和 if 类似, while 下面的语句可以不写 { } , 但是不写的时候只能支持一条语句. 建议还是加上 { }</p></li><li><p>和 if 类似, while 后面的 { 建议和 while 写在同一行.</p></li><li><p>和 if 类似, while 后面不要多写 分号, 否则可能导致循环不能正确执行.</p></li></ol><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">        循环体;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表达式1: 用于初始化循环变量.</p><p>表达式2: 循环条件</p><p>表达式3: 更新循环变量. </p></blockquote><p>代码示例1: 打印 1 - 10 的数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>注意事项 (和while循环类似)</strong></p><ol><li><p>和 if 类似, for 下面的语句可以不写 { } , 但是不写的时候只能支持一条语句. 建议还是加上 { }</p></li><li><p>和 if 类似, for 后面的 { 建议和 while 写在同一行.</p></li><li><p>和 if 类似, for 后面不要多写 分号, 否则可能导致循环不能正确执行</p></li></ol><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h3><p>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">         循环语句;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br><span class="line"><span class="comment">// 先执行循环语句, 再判定循环条件</span></span><br></pre></td></tr></table></figure><p>代码示例: 打印 1 - 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">num++;</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li>do while 循环最后的分号不要忘记</li><li>一般 do while 很少用到, 更推荐使用 for 和 while</li></ol><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break 的功能是让循环提前结束</p><p>代码示例: 找到 100 - 200 中第一个 3 的倍数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">200</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了 3 的倍数, 为:&quot;</span> + num);</span><br><span class="line"><span class="keyword">break</span>;    </span><br><span class="line">&#125;</span><br><span class="line">         num++;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行结果 找到了 3 的倍数, 为:102</span></span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue 的功能是跳过这次循环, 立即进入下次循环</p><p>代码示例: 找到 100 - 200 中所有 3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (num &lt;= <span class="number">200</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">num++; <span class="comment">// 这里的 ++ 不要忘记! 否则会死循环.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;找到了 3 的倍数, 为:&quot;</span> + num);</span><br><span class="line">    num++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码实现思想：当数字不是3的倍数的时候，利用continue的跳出本次循环的特性，就不会实现实现后面的打印语句，如果num的值为3的倍数的时候，就不会进入if语句中，从而打印出来。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(msg); <span class="comment">// 输出一个字符串, 带换行</span></span><br><span class="line"></span><br><span class="line">System.out.print(msg); <span class="comment">// 输出一个字符串, 不带换行</span></span><br><span class="line"></span><br><span class="line">System.out.printf(format, msg); <span class="comment">// 格式化输出 </span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;换行输出&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;不换行输出&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为：</span><br><span class="line">换行输出</span><br><span class="line">不换行输出</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>4.2 从键盘输入</p><p><img src="F:/photoBox/typora%E5%9B%BE%E5%BA%93/image-20211119135431604.png" alt="image-20211119135431604"></p><p> 需要用到Scnner类，在之后会讲什么是类，目前只需要如何使用就可以了。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
